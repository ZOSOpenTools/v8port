diff --git a/BUILD.gn b/BUILD.gn
index dc2bb62a406..524a238b496 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -797,6 +797,12 @@ config("libbase_config") {
   }
 }
 
+config("zoslib_config") {
+  if (current_os == "zos") {
+    configs = [ "//third_party/zoslib:zoslib_config" ]
+  }
+}
+
 # Standalone cppgc cannot be built within chrome or with perfetto.
 assert(!cppgc_is_standalone || !build_with_chromium)
 assert(!cppgc_is_standalone || !v8_use_perfetto)
@@ -1329,7 +1335,7 @@ config("toolchain") {
     }
     if (host_byteorder == "little") {
       defines += [ "V8_TARGET_ARCH_S390_LE_SIM" ]
-    } else {
+    } else if (current_os != "zos") {
       cflags += [ "-march=z196" ]
     }
   }
@@ -2216,6 +2222,12 @@ group("v8_abseil") {
   ]
 }
 
+group("zoslib") {
+  if (current_os == "zos") {
+    deps = [ "//third_party/zoslib" ]
+  }
+}
+
 v8_header_set("torque_runtime_support") {
   visibility = [ ":*" ]
 
@@ -2347,6 +2359,12 @@ template("run_mksnapshot") {
 
     data = []
 
+    if (current_os != "zos") {
+      ext = "S"
+    } else {
+      ext = "s"
+    }
+
     args = [
       "./" + rebase_path(get_label_info(":mksnapshot($v8_snapshot_toolchain)",
                                         "root_out_dir") + "/mksnapshot",
@@ -2362,7 +2380,7 @@ template("run_mksnapshot") {
       "--target_arch=$current_cpu",
 
       "--embedded_src",
-      rebase_path("$target_gen_dir/embedded${suffix}.S", root_build_dir),
+      rebase_path("$target_gen_dir/embedded${suffix}.${ext}", root_build_dir),
     ]
 
     if (v8_log_builtins_block_count_input != "") {
@@ -2405,7 +2423,7 @@ template("run_mksnapshot") {
 
     args += invoker.args
 
-    outputs += [ "$target_gen_dir/embedded${suffix}.S" ]
+    outputs += [ "$target_gen_dir/embedded${suffix}.${ext}" ]
     if (invoker.embedded_variant != "") {
       args += [
         "--embedded_variant",
@@ -2710,7 +2728,11 @@ v8_source_set("v8_snapshot") {
     deps += [ ":asm_to_inline_asm_default" ]
     sources += [ "$target_gen_dir/embedded.cc" ]
   } else {
-    sources += [ "$target_gen_dir/embedded.S" ]
+    if (current_os != "zos") {
+      sources += [ "$target_gen_dir/embedded.S" ]
+    } else {
+      sources += [ "$target_gen_dir/embedded.s" ]
+    }
   }
 
   configs = [ ":internal_config" ]
@@ -5973,7 +5995,8 @@ v8_source_set("v8_base_without_compiler") {
   # to implement atomic memory access
   if (v8_current_cpu == "mips64" || v8_current_cpu == "mips64el" ||
       v8_current_cpu == "ppc" || v8_current_cpu == "ppc64" ||
-      v8_current_cpu == "s390" || v8_current_cpu == "s390x" ||
+      (current_os != "zos" &&
+      (v8_current_cpu == "s390" || v8_current_cpu == "s390x")) ||
       v8_current_cpu == "riscv64" || v8_current_cpu == "riscv32") {
     if (!is_clang) {
       libs += [ "atomic" ]
@@ -6247,6 +6270,11 @@ v8_component("v8_libbase") {
 
   deps = [ ":v8_config_headers" ]
 
+  if (current_os == "zos") {
+    public_configs += [ ":zoslib_config" ]
+    deps += [ ":zoslib" ]
+  }
+
   libs = []
 
   data = []
@@ -6264,7 +6292,7 @@ v8_component("v8_libbase") {
       "src/base/platform/platform-posix.cc",
       "src/base/platform/platform-posix.h",
     ]
-    if (current_os != "aix") {
+    if (current_os != "aix" && current_os != "zos") {
       sources += [
         "src/base/platform/platform-posix-time.cc",
         "src/base/platform/platform-posix-time.h",
@@ -6356,6 +6384,11 @@ v8_component("v8_libbase") {
     }
 
     data_deps += [ "//build/win:runtime_libs" ]
+  } else if (current_os == "zos") {
+    sources += [
+      "src/base/debug/stack_trace_zos.cc",
+      "src/base/platform/platform-zos.cc",
+    ]
   }
 
   if (v8_current_cpu == "mips64") {
@@ -6575,6 +6608,8 @@ v8_source_set("v8_heap_base") {
       sources += [ "src/heap/base/asm/arm64/push_registers_asm.cc" ]
     } else if (current_cpu == "ppc64") {
       sources += [ "src/heap/base/asm/ppc/push_registers_asm.cc" ]
+    } else if (current_os == "zos") {
+      sources += [ "src/heap/base/asm/zos/push_registers_asm.cc" ]
     } else if (current_cpu == "s390x") {
       sources += [ "src/heap/base/asm/s390/push_registers_asm.cc" ]
     } else if (current_cpu == "mips64el") {
@@ -6668,6 +6703,10 @@ v8_header_set("cppgc_headers") {
     ":v8_libplatform",
   ]
 
+  if (current_os == "zos" && is_component_build) {
+    deps += [ ":zoslib" ]
+  }
+
   public_deps = [ ":v8_config_headers" ]
 }
 
@@ -6934,6 +6973,8 @@ if (current_toolchain == v8_snapshot_toolchain) {
       "src/snapshot/embedded/platform-embedded-file-writer-mac.h",
       "src/snapshot/embedded/platform-embedded-file-writer-win.cc",
       "src/snapshot/embedded/platform-embedded-file-writer-win.h",
+      "src/snapshot/embedded/platform-embedded-file-writer-zos.cc",
+      "src/snapshot/embedded/platform-embedded-file-writer-zos.h",
       "src/snapshot/mksnapshot.cc",
       "src/snapshot/snapshot-empty.cc",
       "src/snapshot/static-roots-gen.cc",
@@ -7359,6 +7400,9 @@ v8_executable("d8") {
   if (v8_enable_vtunejit) {
     deps += [ "src/third_party/vtune:v8_vtune" ]
   }
+  if (current_os == "zos" && is_component_build) {
+    deps += [ ":zoslib" ]
+  }
 }
 
 v8_executable("v8_hello_world") {
@@ -7395,6 +7439,9 @@ v8_executable("v8_sample_process") {
     ":v8_libplatform",
     "//build/win:default_exe_manifest",
   ]
+  if (current_os == "zos" && is_component_build) {
+    deps += [ ":zoslib" ]
+  }
 }
 
 if (want_v8_shell) {
@@ -7414,6 +7461,9 @@ if (want_v8_shell) {
       ":v8_libplatform",
       "//build/win:default_exe_manifest",
     ]
+    if (current_os == "zos" && is_component_build) {
+      deps += [ ":zoslib" ]
+    }
   }
 }
 
diff --git a/include/v8-platform.h b/include/v8-platform.h
index c3b04f30899..1a6d67ee361 100644
--- a/include/v8-platform.h
+++ b/include/v8-platform.h
@@ -16,6 +16,12 @@
 #include "v8-source-location.h"  // NOLINT(build/include_directory)
 #include "v8config.h"  // NOLINT(build/include_directory)
 
+#if V8_OS_ZOS
+// TODO(gabylb): zos - this conflicts with base_ def'n in ptr-compr.h
+// thread_local workaroud.
+#undef base_
+#endif
+
 namespace v8 {
 
 class Isolate;
diff --git a/include/v8config.h b/include/v8config.h
index 7995cfd3588..322ef1791ed 100644
--- a/include/v8config.h
+++ b/include/v8config.h
@@ -22,6 +22,8 @@ path. Add it with -I<path> to the command line
 # include <TargetConditionals.h>
 #elif defined(__linux__)
 # include <features.h>
+#elif defined(__MVS__)
+# include "zos-base.h"
 #endif
 
 
@@ -162,6 +164,11 @@ path. Add it with -I<path> to the command line
 #elif defined(_WIN32)
 # define V8_OS_WIN 1
 # define V8_OS_STRING "windows"
+
+#elif defined(__MVS__)
+# define V8_OS_POSIX 1
+# define V8_OS_ZOS 1
+# define V8_OS_STRING "zos"
 #endif
 
 // -----------------------------------------------------------------------------
diff --git a/src/base/contextual.h b/src/base/contextual.h
index 3b81c50d115..e3e5f86fdee 100644
--- a/src/base/contextual.h
+++ b/src/base/contextual.h
@@ -11,6 +11,12 @@
 #include "src/base/macros.h"
 #include "src/base/platform/platform.h"
 
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+class V8_NODISCARD Scope;
+#define top_ (*__top_impl.access())
+#endif
+
 namespace v8::base {
 
 // {ContextualVariable} provides a clean alternative to a global variable.
@@ -69,7 +75,13 @@ class V8_EXPORT_PRIVATE ContextualVariable {
   static bool HasScope() { return Top() != nullptr; }
 
  private:
+#if V8_OS_ZOS
+  // TODO(gabylb): zos - undo when thread_local is supported.
+  [[clang::no_destroy]]
+  inline static __tlssim<Scope*> __top_impl;
+#else
   inline static thread_local Scope* top_ = nullptr;
+#endif
 
 #if defined(USING_V8_SHARED)
   // Hide the access to `top_` from other DLLs/libraries, since access to
diff --git a/src/base/platform/memory.h b/src/base/platform/memory.h
index 48b0d70ec16..3dff9a27d6e 100644
--- a/src/base/platform/memory.h
+++ b/src/base/platform/memory.h
@@ -19,13 +19,15 @@
 
 #if V8_OS_DARWIN
 #include <malloc/malloc.h>
-#else  // !V8_OS_DARWIN
+#elif V8_OS_ZOS
+#include <stdlib.h>
+#else
 #include <malloc.h>
-#endif  // !V8_OS_DARWIN
+#endif
 
-#if (V8_OS_POSIX && !V8_OS_AIX && !V8_OS_SOLARIS) || V8_OS_WIN
+#if (V8_OS_POSIX && !V8_OS_AIX && !V8_OS_SOLARIS && !V8_OS_ZOS) || V8_OS_WIN
 #define V8_HAS_MALLOC_USABLE_SIZE 1
-#endif  // (V8_OS_POSIX && !V8_OS_AIX && !V8_OS_SOLARIS) || V8_OS_WIN
+#endif
 
 namespace v8::base {
 
@@ -85,6 +87,8 @@ inline void* AlignedAlloc(size_t size, size_t alignment) {
   return memalign(alignment, size);
 #elif V8_OS_STARBOARD
   return SbMemoryAllocateAligned(alignment, size);
+#elif V8_OS_ZOS
+  return __zalloc(size, alignment);
 #else   // POSIX
   void* ptr;
   if (posix_memalign(&ptr, alignment, size)) ptr = nullptr;
diff --git a/src/base/platform/mutex.cc b/src/base/platform/mutex.cc
index c1f15cb2c70..78ee5ad2cbb 100644
--- a/src/base/platform/mutex.cc
+++ b/src/base/platform/mutex.cc
@@ -27,9 +27,21 @@ namespace {
 // thread. If this thread has only one held shared mutex (common case), we use
 // {single_held_shared_mutex}. If it has more than one we allocate a set for it.
 // Said set has to manually be constructed and destroyed.
-thread_local base::SharedMutex* single_held_shared_mutex = nullptr;
+
 using TSet = std::unordered_set<base::SharedMutex*>;
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<base::SharedMutex*> __single_held_shared_mutex_impl(nullptr);
+#define single_held_shared_mutex (*__single_held_shared_mutex_impl.access())
+
+[[clang::no_destroy]]
+__tlssim<TSet*> __held_shared_mutexes_impl(nullptr);
+#define held_shared_mutexes (*__held_shared_mutexes_impl.access())
+#else
+thread_local base::SharedMutex* single_held_shared_mutex = nullptr;
 thread_local TSet* held_shared_mutexes = nullptr;
+#endif
 
 // Returns true iff {shared_mutex} is not a held mutex.
 bool SharedMutexNotHeld(SharedMutex* shared_mutex) {
diff --git a/src/base/platform/platform-posix.cc b/src/base/platform/platform-posix.cc
index 116ba4f9d9f..3a25a0cc9af 100644
--- a/src/base/platform/platform-posix.cc
+++ b/src/base/platform/platform-posix.cc
@@ -42,6 +42,7 @@
 #include "src/base/platform/platform.h"
 #include "src/base/platform/time.h"
 #include "src/base/utils/random-number-generator.h"
+#include "src/common/globals.h"
 
 #ifdef V8_FAST_TLS_SUPPORTED
 #include <atomic>
@@ -54,7 +55,7 @@
 #if V8_OS_DARWIN
 #include <mach/mach.h>
 #include <malloc/malloc.h>
-#else
+#elif !V8_OS_ZOS
 #include <malloc.h>
 #endif
 
@@ -68,7 +69,7 @@
 #include <sys/resource.h>
 #endif
 
-#if !defined(_AIX) && !defined(V8_OS_FUCHSIA)
+#if !defined(_AIX) && !defined(V8_OS_FUCHSIA) && !defined(V8_OS_ZOS)
 #include <sys/syscall.h>
 #endif
 
@@ -98,7 +99,11 @@ namespace base {
 namespace {
 
 // 0 is never a valid thread id.
+#if V8_OS_ZOS
+const pthread_t kNoThread = {0};
+#else
 const pthread_t kNoThread = static_cast<pthread_t>(0);
+#endif
 
 const char* g_gc_fake_mmap = nullptr;
 
@@ -106,7 +111,7 @@ DEFINE_LAZY_LEAKY_OBJECT_GETTER(RandomNumberGenerator,
                                 GetPlatformRandomNumberGenerator)
 static LazyMutex rng_mutex = LAZY_MUTEX_INITIALIZER;
 
-#if !V8_OS_FUCHSIA
+#if !V8_OS_FUCHSIA && !V8_OS_ZOS
 #if V8_OS_DARWIN
 // kMmapFd is used to pass vm_alloc flags to tag the region with the user
 // defined tag 255 This helps identify V8-allocated regions in memory analysis
@@ -181,7 +186,7 @@ void* Allocate(void* hint, size_t size, OS::MemoryPermission access,
   return result;
 }
 
-#endif  // !V8_OS_FUCHSIA
+#endif  // !V8_OS_FUCHSIA && !V8_OS_ZOS
 
 }  // namespace
 
@@ -346,6 +351,14 @@ void* OS::GetRandomMmapAddr() {
   // Little-endian Linux: 46 bits of virtual addressing.
   raw_addr &= uint64_t{0x3FFFFFFF0000};
 #endif
+#elif V8_OS_ZOS
+  // https://www.ibm.com/docs/en/zos/2.4.0?topic=functions-mmap-map-pages-memory
+  // TODO(gabylb): zos - 64 bits of virtual addressing on z/OS, however mmap
+  // is currently not fully supported (e.g. no support yet for MAP_ANONYMOUS),
+  // and allocating in 64-bit storage requires special system config, so limit
+  // to below the 2gb bar till full use of mmap is enabled on z/OS.
+  raw_addr &= uint64_t{0x7FFFFFFF};
+  raw_addr = RoundDown(raw_addr, AllocatePageSize());
 #elif V8_TARGET_ARCH_S390X
   // Linux on Z uses bits 22-32 for Region Indexing, which translates to 42 bits
   // of virtual addressing.  Truncate to 40 bits to allow kernel chance to
@@ -402,6 +415,8 @@ void* OS::GetRandomMmapAddr() {
 
 // TODO(bbudge) Move Cygwin and Fuchsia stuff into platform-specific files.
 #if !V8_OS_CYGWIN && !V8_OS_FUCHSIA
+// TODO(gabylb): zos - z/OS specific implementation in platform-zos.cc.
+#if !V8_OS_ZOS
 // static
 void* OS::Allocate(void* hint, size_t size, size_t alignment,
                    MemoryPermission access) {
@@ -603,6 +618,7 @@ bool OS::DecommitPages(void* address, size_t size) {
   return true;
 }
 #endif  // !defined(_AIX)
+#endif  // !V8_OS_ZOS
 
 // static
 bool OS::CanReserveAddressSpace() { return true; }
@@ -670,6 +686,7 @@ void OS::DestroySharedMemoryHandle(PlatformSharedMemoryHandle handle) {
 }
 #endif  // !defined(V8_OS_DARWIN)
 
+#if !V8_OS_ZOS
 // static
 bool OS::HasLazyCommits() {
 #if V8_OS_AIX || V8_OS_LINUX || V8_OS_DARWIN
@@ -679,6 +696,7 @@ bool OS::HasLazyCommits() {
   return false;
 #endif
 }
+#endif  // !V8_OS_ZOS
 #endif  // !V8_OS_CYGWIN && !V8_OS_FUCHSIA
 
 const char* OS::GetGCFakeMMapFile() {
@@ -722,6 +740,9 @@ void OS::DebugBreak() {
   asm("int $3");
 #elif V8_HOST_ARCH_X64
   asm("int $3");
+#elif V8_OS_ZOS
+  // TODO(gabylb): zos - implement when a debugger is supported.
+  UNREACHABLE();
 #elif V8_HOST_ARCH_S390
   // Software breakpoint instruction is 0x0001
   asm volatile(".word 0x0001");
@@ -735,6 +756,7 @@ void OS::DebugBreak() {
 }
 
 
+#if !V8_OS_ZOS
 class PosixMemoryMappedFile final : public OS::MemoryMappedFile {
  public:
   PosixMemoryMappedFile(FILE* file, void* memory, size_t size)
@@ -804,6 +826,7 @@ PosixMemoryMappedFile::~PosixMemoryMappedFile() {
   if (memory_) OS::Free(memory_, RoundUp(size_, OS::AllocatePageSize()));
   fclose(file_);
 }
+#endif  // !V8_OS_ZOS
 
 
 int OS::GetCurrentProcessId() {
@@ -824,6 +847,8 @@ int OS::GetCurrentThreadId() {
   return static_cast<int>(zx_thread_self());
 #elif V8_OS_SOLARIS
   return static_cast<int>(pthread_self());
+#elif V8_OS_ZOS
+  return static_cast<int>(pthread_self().__ & 0x7fffffff);
 #else
   return static_cast<int>(reinterpret_cast<intptr_t>(pthread_self()));
 #endif
@@ -856,6 +881,8 @@ int OS::GetPeakMemoryUsageKb() {
 #if defined(V8_OS_FUCHSIA)
   // Fuchsia does not implement getrusage()
   return -1;
+#elif defined(V8_OS_ZOS) && __EDC_TARGET <= 0x42050000
+  return -1;
 #else
   struct rusage usage;
   if (getrusage(RUSAGE_SELF, &usage) < 0) return -1;
@@ -1052,6 +1079,8 @@ bool AddressSpaceReservation::Free(void* address, size_t size) {
   return OS::DecommitPages(address, size);
 }
 
+// z/OS specific implementation in platform-zos.cc.
+#if !defined(V8_OS_ZOS)
 // Darwin specific implementation in platform-darwin.cc.
 #if !defined(V8_OS_DARWIN)
 bool AddressSpaceReservation::AllocateShared(void* address, size_t size,
@@ -1071,6 +1100,7 @@ bool AddressSpaceReservation::FreeShared(void* address, size_t size) {
   return mmap(address, size, PROT_NONE, MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE,
               -1, 0) == address;
 }
+#endif  // !V8_OS_ZOS
 
 bool AddressSpaceReservation::SetPermissions(void* address, size_t size,
                                              OS::MemoryPermission access) {
@@ -1209,6 +1239,16 @@ bool Thread::Start() {
 #elif V8_OS_AIX
     // Default on AIX is 96kB -- bump up to 2MB
     stack_size = 2 * 1024 * 1024;
+#elif V8_OS_ZOS
+    // On z/OS if the _CEE_RUNOPTS STACK64/THREADSTACK64 initial stack size is
+    // less than V8_DEFAULT_STACK_SIZE_KB * KB (default for FLAG_stack_size),
+    // bump it to that default:
+    const size_t default_stack_size = V8_DEFAULT_STACK_SIZE_KB \
+                                      * ::v8::internal::KB;
+    result = pthread_attr_getstacksize(&attr, &stack_size);
+    DCHECK_EQ(0, result);
+    if (stack_size < default_stack_size)
+        stack_size = default_stack_size;
 #endif
   }
   if (stack_size > 0) {
@@ -1322,6 +1362,9 @@ bool MainThreadIsCurrentThread() {
 
 // static
 Stack::StackSlot Stack::ObtainCurrentThreadStackStart() {
+#if V8_OS_ZOS
+  return __get_stack_start();
+#else
   pthread_attr_t attr;
   int error = pthread_getattr_np(pthread_self(), &attr);
   if (error) {
@@ -1351,6 +1394,7 @@ Stack::StackSlot Stack::ObtainCurrentThreadStackStart() {
   }
 #endif  // !defined(V8_LIBC_GLIBC)
   return stack_start;
+#endif  // V8_OS_ZOS
 }
 
 #endif  // !defined(V8_OS_FREEBSD) && !defined(V8_OS_DARWIN) &&
diff --git a/src/base/platform/platform.cc b/src/base/platform/platform.cc
index 328e9d890d6..c075c32d67c 100644
--- a/src/base/platform/platform.cc
+++ b/src/base/platform/platform.cc
@@ -10,8 +10,14 @@ namespace base {
 namespace {
 
 // A pointer to current thread's stack beginning.
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<void*> __thread_stack_start_impl(nullptr);
+#define thread_stack_start (*__thread_stack_start_impl.access())
+#else
 thread_local void* thread_stack_start = nullptr;
-
+#endif
 }  // namespace
 
 // static
@@ -24,8 +30,12 @@ Stack::StackSlot Stack::GetStackStartUnchecked() {
 
 // static
 Stack::StackSlot Stack::GetStackStart() {
+#if !V8_OS_ZOS
+  // On z/OS, this fails if C is called from JS code, since the stack pointer
+  // is overwritten on entry to JS and so the stack cannot be traversed.
   DCHECK_IMPLIES(thread_stack_start,
                  thread_stack_start == ObtainCurrentThreadStackStart());
+#endif
   return GetStackStartUnchecked();
 }
 
diff --git a/src/base/platform/platform.h b/src/base/platform/platform.h
index 7d5fcef99c0..49eade41767 100644
--- a/src/base/platform/platform.h
+++ b/src/base/platform/platform.h
@@ -64,6 +64,12 @@ extern "C" unsigned long __readfsdword(unsigned long);  // NOLINT(runtime/int)
 #endif                                       // V8_CC_MSVC && V8_HOST_ARCH_IA32
 #endif                                       // V8_NO_FAST_TLS
 
+#if V8_OS_ZOS
+// TODO(gabylb): zos - This conflicts with base_ def'n in ptr-compr.h
+// thread_local workaroud.
+#undef base_
+#endif
+
 namespace v8 {
 
 namespace internal {
@@ -523,6 +529,8 @@ class V8_BASE_EXPORT Thread {
   // Opaque data type for thread-local storage keys.
 #if V8_OS_STARBOARD
   using LocalStorageKey = SbThreadLocalKey;
+#elif V8_OS_ZOS
+  using LocalStorageKey = pthread_key_t;
 #else
   using LocalStorageKey = int32_t;
 #endif
diff --git a/src/base/platform/semaphore.h b/src/base/platform/semaphore.h
index 060f1d2bf05..57c70c4030a 100644
--- a/src/base/platform/semaphore.h
+++ b/src/base/platform/semaphore.h
@@ -13,6 +13,8 @@
 
 #if V8_OS_DARWIN
 #include <dispatch/dispatch.h>
+#elif V8_OS_ZOS
+#include "zos-semaphore.h"
 #elif V8_OS_POSIX
 #include <semaphore.h>
 #endif
diff --git a/src/base/platform/time.cc b/src/base/platform/time.cc
index b6da0a690c0..d036978d77b 100644
--- a/src/base/platform/time.cc
+++ b/src/base/platform/time.cc
@@ -91,7 +91,7 @@ V8_INLINE int64_t GetFuchsiaThreadTicks() {
 // _POSIX_MONOTONIC_CLOCK to -1.
 V8_INLINE int64_t ClockNow(clockid_t clk_id) {
 #if (defined(_POSIX_MONOTONIC_CLOCK) && _POSIX_MONOTONIC_CLOCK >= 0) || \
-  defined(V8_OS_BSD) || defined(V8_OS_ANDROID)
+  defined(V8_OS_BSD) || defined(V8_OS_ANDROID) || defined(V8_OS_ZOS)
 #if defined(V8_OS_AIX)
   // On AIX clock_gettime for CLOCK_THREAD_CPUTIME_ID outputs time with
   // resolution of 10ms. thread_cputime API provides the time in ns.
@@ -791,7 +791,8 @@ bool ThreadTicks::IsSupported() {
   // Thread CPU time accounting is unavailable in PASE
   return false;
 #elif(defined(_POSIX_THREAD_CPUTIME) && (_POSIX_THREAD_CPUTIME >= 0)) || \
-    defined(V8_OS_DARWIN) || defined(V8_OS_ANDROID) || defined(V8_OS_SOLARIS)
+    defined(V8_OS_DARWIN) || defined(V8_OS_ANDROID) || \
+    defined(V8_OS_SOLARIS) || defined(V8_OS_ZOS)
   return true;
 #elif defined(V8_OS_WIN)
   return IsSupportedWin();
@@ -817,7 +818,7 @@ ThreadTicks ThreadTicks::Now() {
 #elif V8_OS_FUCHSIA
   return ThreadTicks(GetFuchsiaThreadTicks());
 #elif(defined(_POSIX_THREAD_CPUTIME) && (_POSIX_THREAD_CPUTIME >= 0)) || \
-  defined(V8_OS_ANDROID)
+  defined(V8_OS_ANDROID) || defined(V8_OS_ZOS)
   return ThreadTicks(ClockNow(CLOCK_THREAD_CPUTIME_ID));
 #elif V8_OS_SOLARIS
   return ThreadTicks(gethrvtime() / Time::kNanosecondsPerMicrosecond);
diff --git a/src/base/sys-info.cc b/src/base/sys-info.cc
index 3d45c8571c3..e5d38953ee1 100644
--- a/src/base/sys-info.cc
+++ b/src/base/sys-info.cc
@@ -45,6 +45,9 @@ int SysInfo::NumberOfProcessors() {
     return 1;
   }
   return ncpu;
+#elif V8_OS_ZOS
+  // This is from zoslib:
+  return __get_num_online_cpus();
 #elif V8_OS_POSIX
   long result = sysconf(_SC_NPROCESSORS_ONLN);  // NOLINT(runtime/int)
   if (result == -1) {
@@ -98,6 +101,10 @@ int64_t SysInfo::AmountOfPhysicalMemory() {
 #elif V8_OS_AIX
   int64_t result = sysconf(_SC_AIX_REALMEM);
   return static_cast<int64_t>(result) * 1024L;
+#elif V8_OS_ZOS
+  int pages = __get_num_frames();
+  long page_size = sysconf(_SC_PAGESIZE);
+  return static_cast<uint64_t>(pages) * page_size;
 #elif V8_OS_POSIX
   long pages = sysconf(_SC_PHYS_PAGES);    // NOLINT(runtime/int)
   long page_size = sysconf(_SC_PAGESIZE);  // NOLINT(runtime/int)
diff --git a/src/builtins/s390/builtins-s390.cc b/src/builtins/s390/builtins-s390.cc
index 4f140667249..efcc13979aa 100644
--- a/src/builtins/s390/builtins-s390.cc
+++ b/src/builtins/s390/builtins-s390.cc
@@ -806,6 +806,35 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 
   Label invoke, handler_entry, exit;
 
+#if V8_OS_ZOS
+  const int stack_space = 12 * kSystemPointerSize;
+
+  // Store r4 - r15 to Stack
+  __ StoreMultipleP(r4, sp, MemOperand(r4, kStackPointerBias -
+                    stack_space));
+  // Grow stack
+  __ lay(r4, MemOperand(r4, -stack_space));
+
+  // Shuffle input XPLINK register arguments to match LoZ
+  __ mov(sp, r4);
+  __ mov(r4, r3);
+  __ mov(r3, r2);
+  __ mov(r2, r1);
+
+  // Load args 4 and 5 from XPLINK extra frame slots in r5 and r6
+  __ LoadMultipleP(r5, r6, MemOperand(sp, kStackPointerBias +
+                   kXPLINKStackFrameExtraParamSlot * kSystemPointerSize +
+                   stack_space));
+
+  // Load arg 6 from XPLINK extra arg slot
+  __ LoadU64(r0, MemOperand(sp, kStackPointerBias +
+             kXPLINKStackFrameExtraParamSlot * kSystemPointerSize +
+             stack_space + 2 * kSystemPointerSize));
+
+  // Store arg 6 to expected LoZ save area
+  __ StoreU64(r0, MemOperand(sp, kCalleeRegisterSaveAreaSize));
+#endif
+
   int pushed_stack_space = 0;
   {
     NoRootArrayScope no_root_array(masm);
@@ -836,7 +865,9 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
     //    General convention is to also save r14 (return addr) and
     //    sp/r15 as well in a single STM/STMG
     __ lay(sp, MemOperand(sp, -10 * kSystemPointerSize));
+#if !V8_OS_ZOS
     __ StoreMultipleP(r6, sp, MemOperand(sp, 0));
+#endif
     pushed_stack_space += (kNumCalleeSaved + 2) * kSystemPointerSize;
 
     // Initialize the root register.
@@ -977,7 +1008,9 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   __ lay(sp, MemOperand(sp, -EntryFrameConstants::kNextExitFrameFPOffset));
 
   // Reload callee-saved preserved regs, return address reg (r14) and sp
+#if !V8_OS_ZOS
   __ LoadMultipleP(r6, sp, MemOperand(sp, 0));
+#endif
   __ la(sp, MemOperand(sp, 10 * kSystemPointerSize));
 
 // saving floating point registers
@@ -1000,7 +1033,15 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   __ la(sp, MemOperand(sp, 2 * kDoubleSize));
 #endif
 
+#if V8_OS_ZOS
+  // On z/OS, the return register is r3
+  __ mov(r3, r2);
+  // Restore r4 - r15 from Stack
+  __ LoadMultipleP(r4, sp, MemOperand(sp, kStackPointerBias));
+  __ b(r7);
+#else
   __ b(r14);
+#endif
 }
 
 }  // namespace
@@ -3236,11 +3277,20 @@ void Builtins::Generate_CEntry(MacroAssembler* masm, int result_size,
                                          : StackFrame::EXIT);
 
   // Store a copy of argc, argv in callee-saved registers for later.
+#if V8_OS_ZOS
+  __ mov(r9, r2);
+  __ mov(r13, r3);
+  // r2, r9: number of arguments including receiver  (C callee-saved)
+  // r3, r13: pointer to the first argument
+  // r7: pointer to builtin function descriptor (C callee-saved)
+  // r8: pointer to builtin function (C callee-saved)
+#else
   __ mov(r6, r2);
   __ mov(r8, r3);
   // r2, r6: number of arguments including receiver  (C callee-saved)
   // r3, r8: pointer to the first argument
   // r7: pointer to builtin function  (C callee-saved)
+#endif
 
   // Result returned in registers or stack, depending on result size and ABI.
 
@@ -3262,6 +3312,42 @@ void Builtins::Generate_CEntry(MacroAssembler* masm, int result_size,
   // Call C built-in.
   __ Move(isolate_reg, ExternalReference::isolate_address(masm->isolate()));
 
+#if V8_OS_ZOS
+  // Shuffle input arguments to match XPLINK ABI
+  __ mov(r1, r2);
+  __ mov(r2, r3);
+  __ mov(r3, r4);
+  // Save stack arguments to XPLINK extra param slot
+  const int stack_args = 3;
+  const int stack_space = kXPLINKStackFrameExtraParamSlot + stack_args;
+  __ lay(r4, MemOperand(sp, -((stack_space * kSystemPointerSize) +
+             kStackPointerBias)));
+  __ StoreMultipleP(r5, r7,
+                    MemOperand(r4, kStackPointerBias +
+                    kXPLINKStackFrameExtraParamSlot * kSystemPointerSize));
+  // Load environment from slot 0 of fn desc.
+  __ LoadU64(r5, MemOperand(r7));
+  // Load function pointer from slot 1 of fn desc.
+  __ LoadU64(r8, MemOperand(r7, kSystemPointerSize));
+  __ StoreReturnAddressAndCall(r8);
+
+  // r9 and r13 are used to store argc and argv on z/OS instead
+  // of r6 and r8 since r6 is not callee saved.
+  __ mov(r6, r9);
+  __ mov(r8, r13);
+
+  // Shuffler arguments based on result_size to match XPLINK ABI
+  if (result_size == 1) {
+    __ mov(r2, r3);
+  } else if (result_size == 2) {
+    __ mov(r3, r2);
+    __ mov(r2, r1);
+  } else {
+    __ mov(r4, r3);
+    __ mov(r3, r2);
+    __ mov(r2, r1);
+  }
+#else
   __ StoreReturnAddressAndCall(r7);
 
   // If return value is on the stack, pop it to registers.
@@ -3270,6 +3356,7 @@ void Builtins::Generate_CEntry(MacroAssembler* masm, int result_size,
     __ LoadU64(r3, MemOperand(r2, kSystemPointerSize));
     __ LoadU64(r2, MemOperand(r2));
   }
+#endif
 
   // Check result for exception sentinel.
   Label exception_returned;
diff --git a/src/codegen/assembler.cc b/src/codegen/assembler.cc
index ce7b1ebef08..c6efd68be7d 100644
--- a/src/codegen/assembler.cc
+++ b/src/codegen/assembler.cc
@@ -131,11 +131,24 @@ class ExternalAssemblerBufferImpl : public AssemblerBuffer {
   const int size_;
 };
 
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+static __tlssim<std::aligned_storage_t<sizeof(ExternalAssemblerBufferImpl),
+                                       alignof(ExternalAssemblerBufferImpl)>>
+                                       __x_impl;
+#define tls_singleton_storage (*__x_impl.access())
+
+[[clang::no_destroy]]
+static __tlssim<bool> __tls_singleton_taken_impl{false};
+#define tls_singleton_taken (*__tls_singleton_taken_impl.access())
+#else
 static thread_local std::aligned_storage_t<sizeof(ExternalAssemblerBufferImpl),
                                            alignof(ExternalAssemblerBufferImpl)>
     tls_singleton_storage;
 
 static thread_local bool tls_singleton_taken{false};
+#endif
 
 void* ExternalAssemblerBufferImpl::operator new(std::size_t count) {
   DCHECK_EQ(count, sizeof(ExternalAssemblerBufferImpl));
diff --git a/src/codegen/s390/assembler-s390.cc b/src/codegen/s390/assembler-s390.cc
index c78cb668651..81fbc17c3a8 100644
--- a/src/codegen/s390/assembler-s390.cc
+++ b/src/codegen/s390/assembler-s390.cc
@@ -40,7 +40,7 @@
 
 #if V8_TARGET_ARCH_S390
 
-#if V8_HOST_ARCH_S390
+#if V8_HOST_ARCH_S390 && !V8_OS_ZOS
 #include <elf.h>  // Required for auxv checks for STFLE support
 #include <sys/auxv.h>
 #endif
@@ -50,6 +50,9 @@
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/s390/assembler-s390-inl.h"
 #include "src/deoptimizer/deoptimizer.h"
+#if V8_OS_ZOS
+#include "zos-sys-info.h"
+#endif
 
 namespace v8 {
 namespace internal {
@@ -61,6 +64,19 @@ static unsigned CpuFeaturesImpliedByCompiler() {
 }
 
 static bool supportsCPUFeature(const char* feature) {
+#if V8_OS_ZOS
+  // TODO(gabylb): zos - use cpu_init() and cpu_supports() to test support of
+  // z/OS features once the current compiler supports them.
+  // Currently the only feature to be checked is Vector Extension Facility
+  // ("vector128" on z/OS, "vx" on LoZ) - hence the assert in case that changed.
+  assert(strcmp(feature, "vx") == 0);
+  // CVT: https://www.ibm.com/docs/en/zos/2.4.0?topic=correlator-cvt-information
+  // ZOSCVT is from zoslib; bit 7 (0x80) at CVT offset 244 is Vector Extension
+  // Facility:
+  ZOSCVT* __ptr32 cvt = ((ZOSPSA*)0)->cvt;
+  uint8_t CVTFLAG5 = (reinterpret_cast<uint8_t*>(cvt))[244];
+  return CVTFLAG5 & 0x80;
+#else
   static std::set<std::string>& features = *new std::set<std::string>();
   static std::set<std::string>& all_available_features =
       *new std::set<std::string>({"iesan3", "zarch", "stfle", "msa", "ldisp",
@@ -96,6 +112,7 @@ static bool supportsCPUFeature(const char* feature) {
   }
   USE(all_available_features);
   return features.find(feature) != features.end();
+#endif  // !V8_OS_ZOS
 }
 
 #undef CHECK_AVAILABILITY_FOR
@@ -104,7 +121,10 @@ static bool supportsCPUFeature(const char* feature) {
 // Check whether Store Facility STFLE instruction is available on the platform.
 // Instruction returns a bit vector of the enabled hardware facilities.
 static bool supportsSTFLE() {
-#if V8_HOST_ARCH_S390
+#if V8_OS_ZOS
+  // Use API from zoslib:
+  return __is_stfle_available();
+#elif V8_HOST_ARCH_S390
   static bool read_tried = false;
   static uint32_t auxv_hwcap = 0;
 
@@ -191,6 +211,10 @@ void CpuFeatures::ProbeImpl(bool cross_compile) {
     //   Bit 45 - Distinct Operands for instructions like ARK, SRK, etc.
     // As such, we require only 1 double word
     int64_t facilities[3] = {0L};
+#if V8_OS_ZOS
+    int64_t reg0 = 2;
+    asm volatile(" stfle %0":"=m"(facilities), "+NR:r0"(reg0)::"cc");
+#else
     int16_t reg0;
     // LHI sets up GPR0
     // STFLE is specified as .insn, as opcode is not recognized.
@@ -201,6 +225,7 @@ void CpuFeatures::ProbeImpl(bool cross_compile) {
         : "=Q"(facilities), "=r"(reg0)
         :
         : "cc", "r0");
+#endif  // !V8_OS_ZOS
 
     uint64_t one = static_cast<uint64_t>(1);
     // Test for Distinct Operands Facility - Bit 45
@@ -671,6 +696,17 @@ void Assembler::nop(int type) {
       // TODO(john.yan): Use a better NOP break
       oill(r3, Operand::Zero());
       break;
+#if V8_OS_ZOS
+    case BASR_CALL_TYPE_NOP:
+      emit2bytes(0x0000);
+      break;
+    case BRAS_CALL_TYPE_NOP:
+      emit2bytes(0x0001);
+      break;
+    case BRASL_CALL_TYPE_NOP:
+      emit2bytes(0x0011);
+      break;
+#endif  // V8_OS_ZOS
     default:
       UNIMPLEMENTED();
   }
diff --git a/src/codegen/s390/assembler-s390.h b/src/codegen/s390/assembler-s390.h
index 1434daa3ec1..c14395d2180 100644
--- a/src/codegen/s390/assembler-s390.h
+++ b/src/codegen/s390/assembler-s390.h
@@ -41,7 +41,7 @@
 #define V8_CODEGEN_S390_ASSEMBLER_S390_H_
 #include <stdio.h>
 #include <memory>
-#if V8_HOST_ARCH_S390
+#if V8_HOST_ARCH_S390 && !V8_OS_ZOS
 // elf.h include is required for auxv check for STFLE facility used
 // for hardware detection, which is sensible only on s390 hosts.
 #include <elf.h>
@@ -58,27 +58,6 @@
 #include "src/codegen/s390/register-s390.h"
 #include "src/objects/smi.h"
 
-#define ABI_USES_FUNCTION_DESCRIPTORS 0
-
-#define ABI_PASSES_HANDLES_IN_REGS 1
-
-// ObjectPair is defined under runtime/runtime-util.h.
-// On 31-bit, ObjectPair == uint64_t.  ABI dictates long long
-//            be returned with the lower addressed half in r2
-//            and the higher addressed half in r3. (Returns in Regs)
-// On 64-bit, ObjectPair is a Struct.  ABI dictaes Structs be
-//            returned in a storage buffer allocated by the caller,
-//            with the address of this buffer passed as a hidden
-//            argument in r2. (Does NOT return in Regs)
-// For x86 linux, ObjectPair is returned in registers.
-#if V8_TARGET_ARCH_S390X
-#define ABI_RETURNS_OBJECTPAIR_IN_REGS 0
-#else
-#define ABI_RETURNS_OBJECTPAIR_IN_REGS 1
-#endif
-
-#define ABI_CALL_VIA_IP 1
-
 namespace v8 {
 namespace internal {
 
@@ -1287,6 +1266,11 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
     NON_MARKING_NOP = 0,
     GROUP_ENDING_NOP,
     DEBUG_BREAK_NOP,
+#if V8_OS_ZOS
+    BASR_CALL_TYPE_NOP,
+    BRAS_CALL_TYPE_NOP,
+    BRASL_CALL_TYPE_NOP,
+#endif
     // IC markers.
     PROPERTY_ACCESS_INLINED,
     PROPERTY_ACCESS_INLINED_CONTEXT,
diff --git a/src/codegen/s390/constants-s390.h b/src/codegen/s390/constants-s390.h
index 1ad001c7dfa..a1bd810cc78 100644
--- a/src/codegen/s390/constants-s390.h
+++ b/src/codegen/s390/constants-s390.h
@@ -26,6 +26,38 @@
 #define UNIMPLEMENTED_S390()
 #endif
 
+#if V8_OS_ZOS
+#define ABI_USES_FUNCTION_DESCRIPTORS 1
+#define ABI_PASSES_HANDLES_IN_REGS 1
+#define ABI_RETURNS_OBJECTPAIR_IN_REGS 1
+#ifdef _EXT
+// Defined in stdlib.h and conflict with those in S390_RS_A_OPCODE_LIST:
+#undef cs
+#undef cds
+#endif
+#else
+#define ABI_USES_FUNCTION_DESCRIPTORS 0
+#define ABI_PASSES_HANDLES_IN_REGS 1
+
+// ObjectPair is defined under runtime/runtime-util.h.
+// On 31-bit, ObjectPair == uint64_t.  ABI dictates long long
+//            be returned with the lower addressed half in r2
+//            and the higher addressed half in r3. (Returns in Regs)
+// On 64-bit, ObjectPair is a Struct.  ABI dictaes Structs be
+//            returned in a storage buffer allocated by the caller,
+//            with the address of this buffer passed as a hidden
+//            argument in r2. (Does NOT return in Regs)
+// For x86 linux, ObjectPair is returned in registers.
+#if V8_TARGET_ARCH_S390X
+#define ABI_RETURNS_OBJECTPAIR_IN_REGS 0
+#else
+#define ABI_RETURNS_OBJECTPAIR_IN_REGS 1
+#endif
+#endif
+
+#define ABI_CALL_VIA_IP 1
+
+
 namespace v8 {
 namespace internal {
 
@@ -33,6 +65,14 @@ namespace internal {
 // between all Code objects in the range.
 constexpr size_t kMaxPCRelativeCodeRangeInMB = 4096;
 
+#if V8_OS_ZOS
+// Used to encode a boolean value when emitting 32 bit
+// opcodes which will indicate the presence of function descriptors
+constexpr int kHasFunctionDescriptorBitShift = 4;
+constexpr int kHasFunctionDescriptorBitMask = 1
+                                              << kHasFunctionDescriptorBitShift;
+#endif
+
 // Number of registers
 const int kNumRegisters = 16;
 
diff --git a/src/codegen/s390/macro-assembler-s390.cc b/src/codegen/s390/macro-assembler-s390.cc
index 2b0b8efe51b..6ea1f5a26ad 100644
--- a/src/codegen/s390/macro-assembler-s390.cc
+++ b/src/codegen/s390/macro-assembler-s390.cc
@@ -428,10 +428,23 @@ void MacroAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
 }
 
 void MacroAssembler::Jump(const ExternalReference& reference) {
+#if V8_OS_ZOS
+  // Place reference into scratch r12 ip register
+  Move(ip, reference);
+  // z/OS uses function descriptors, extract code entry into r6
+  LoadMultipleP(r5, r6, MemOperand(ip, 0));
+  // Preserve return address into r14
+  mov(r14, r7);
+  // Call C Function
+  StoreReturnAddressAndCall(r6);
+  // Branch to return address in r14
+  b(r14);
+#else
   UseScratchRegisterScope temps(this);
   Register scratch = temps.Acquire();
   Move(scratch, reference);
   Jump(scratch);
+#endif
 }
 
 void MacroAssembler::Call(Register target) {
@@ -2512,19 +2525,48 @@ void MacroAssembler::MovToFloatParameters(DoubleRegister src1,
 void MacroAssembler::CallCFunction(ExternalReference function,
                                    int num_reg_arguments,
                                    int num_double_arguments,
+                                   bool has_function_descriptor,
                                    SetIsolateDataSlots set_isolate_data_slots) {
   Move(ip, function);
   CallCFunction(ip, num_reg_arguments, num_double_arguments,
-                set_isolate_data_slots);
+                has_function_descriptor, set_isolate_data_slots);
 }
 
 void MacroAssembler::CallCFunction(Register function, int num_reg_arguments,
                                    int num_double_arguments,
+                                   bool has_function_descriptor,
                                    SetIsolateDataSlots set_isolate_data_slots) {
   ASM_CODE_COMMENT(this);
   DCHECK_LE(num_reg_arguments + num_double_arguments, kMaxCParameters);
   DCHECK(has_frame());
 
+#if V8_OS_ZOS
+  // Shuffle input arguments
+  mov(r1, r2);
+  mov(r2, r3);
+  mov(r3, r4);
+
+  // XPLINK treats r7 as voliatile return register, but r14 as preserved
+  // Since Linux is the other way around, perserve r7 value in r14 across
+  // the call.
+  mov(r14, r7);
+
+  // XPLINK linkage requires args in r5,r6,r7,r8,r9 to be passed on the stack.
+  // However, for DirectAPI C calls, there may not be stack slots
+  // for these 4th and 5th parameters if num_reg_arguments are less
+  // than 3.  In that case, we need to still preserve r5/r6 into
+  // register save area, as they are considered volatile in XPLINK.
+  if (num_reg_arguments == 4) {
+     StoreU64(r5, MemOperand(sp, 19 * kSystemPointerSize));
+     StoreU64(r6, MemOperand(sp, 6 * kSystemPointerSize));
+  } else if (num_reg_arguments >= 5) {
+     // Save original r5 - r6  to Stack, r7 - r9 already saved to Stack
+     StoreMultipleP(r5, r6, MemOperand(sp, 19 * kSystemPointerSize));
+  } else {
+     StoreMultipleP(r5, r6, MemOperand(sp, 5 * kSystemPointerSize));
+  }
+#endif
+
   if (set_isolate_data_slots == SetIsolateDataSlots::kYes) {
     // Save the frame pointer and PC so that the stack layout remains iterable,
     // even without an ExitFrame which normally exists between JS and C frames.
@@ -2537,7 +2579,12 @@ void MacroAssembler::CallCFunction(Register function, int num_reg_arguments,
                               IsolateData::fast_c_call_caller_fp_offset()));
     } else {
       DCHECK_NOT_NULL(isolate());
+#if V8_OS_ZOS
+      // Use r4 as a scratch register on z/OS because r1 represents the 1st arg
+      Register addr_scratch = r4;
+#else
       Register addr_scratch = r1;
+#endif
       Move(addr_scratch,
            ExternalReference::fast_c_call_caller_pc_address(isolate()));
       LoadPC(r0);
@@ -2548,6 +2595,18 @@ void MacroAssembler::CallCFunction(Register function, int num_reg_arguments,
     }
   }
 
+#if V8_OS_ZOS
+  // Set up the system stack pointer with the XPLINK bias.
+  lay(r4, MemOperand(sp, -kStackPointerBias));
+#endif
+
+#if ABI_USES_FUNCTION_DESCRIPTORS && !defined(USE_SIMULATOR)
+  Register dest = function;
+  if (has_function_descriptor) {
+    LoadMultipleP(r5, r6, MemOperand(function, 0));
+    dest = r6;
+  }
+#else
   // Just call directly. The function called cannot cause a GC, or
   // allow preemption, so the return address in the link register
   // stays correct.
@@ -2556,8 +2615,35 @@ void MacroAssembler::CallCFunction(Register function, int num_reg_arguments,
     Move(ip, function);
     dest = ip;
   }
+#endif
+
+#if V8_OS_ZOS
+  if (has_function_descriptor) {
+    // Branch to target via indirect branch
+    basr(r7, dest);
+    nop(BASR_CALL_TYPE_NOP);
+  } else {
+    basr(r7, dest);
+  }
 
+  // Restore r5-r9 from the appropriate stack locations (see notes above).
+  if (num_reg_arguments == 4) {
+     LoadU64(r5, MemOperand(sp, 19 * kSystemPointerSize));
+     LoadU64(r6, MemOperand(sp, 6 * kSystemPointerSize));
+  } else if (num_reg_arguments >= 5) {
+     LoadMultipleP(r5, r6, MemOperand(sp, 19 * kSystemPointerSize));
+  } else {
+     LoadMultipleP(r5, r6, MemOperand(sp, 5 * kSystemPointerSize));
+  }
+
+  // Restore original r7
+  mov(r7, r14);
+
+  // Shuffle the result
+  mov(r2, r3);
+#else
   Call(dest);
+#endif
 
   if (set_isolate_data_slots == SetIsolateDataSlots::kYes) {
     // We don't unset the PC; the FP is the source of truth.
@@ -2590,13 +2676,17 @@ void MacroAssembler::CallCFunction(Register function, int num_reg_arguments,
 
 void MacroAssembler::CallCFunction(ExternalReference function,
                                    int num_arguments,
+                                   bool has_function_descriptor,
                                    SetIsolateDataSlots set_isolate_data_slots) {
-  CallCFunction(function, num_arguments, 0, set_isolate_data_slots);
+  CallCFunction(function, num_arguments, 0, has_function_descriptor,
+                set_isolate_data_slots);
 }
 
 void MacroAssembler::CallCFunction(Register function, int num_arguments,
+                                   bool has_function_descriptor,
                                    SetIsolateDataSlots set_isolate_data_slots) {
-  CallCFunction(function, num_arguments, 0, set_isolate_data_slots);
+  CallCFunction(function, num_arguments, 0, has_function_descriptor,
+                set_isolate_data_slots);
 }
 
 void MacroAssembler::CheckPageFlag(
@@ -5060,9 +5150,20 @@ void MacroAssembler::StoreReturnAddressAndCall(Register target) {
   // currently being generated) is immovable or that the callee function cannot
   // trigger GC, since the callee function will return to it.
 
+#if V8_OS_ZOS
+  Register ra = r7;
+#else
+  Register ra = r14;
+#endif
   Label return_label;
-  larl(r14, &return_label);  // Generate the return addr of call later.
-  StoreU64(r14, MemOperand(sp, kStackFrameRASlot * kSystemPointerSize));
+  larl(ra, &return_label);  // Generate the return addr of call later.
+#if V8_OS_ZOS
+  // Mimic the XPLINK expected no-op (2-byte) instruction at the return point.
+  // When the C call returns, the 2 bytes are skipped and then the proper
+  // instruction is executed.
+  lay(ra, MemOperand(ra, -2));
+#endif
+  StoreU64(ra, MemOperand(sp, kStackFrameRASlot * kSystemPointerSize));
 
   // zLinux ABI requires caller's frame to have sufficient space for callee
   // preserved regsiter save area.
@@ -6400,6 +6501,39 @@ void MacroAssembler::LoadStackLimit(Register destination, StackLimitKind kind) {
   LoadU64(destination, MemOperand(kRootRegister, offset));
 }
 
+#if V8_OS_ZOS
+// Helper for CallApiFunctionAndReturn().
+static inline void zosStoreReturnAddressAndCall(MacroAssembler* masm,
+                                                Register& function_address,
+                                                Register& scratch) {
+  DCHECK(function_address == r3 || function_address == r4);
+  // Shuffle the arguments from Linux arg register to XPLINK arg regs
+  __ mov(r1, r2);
+  if (function_address == r3) {
+    __ mov(r2, r3);
+  } else {
+    __ mov(r2, r3);
+    __ mov(r3, r4);
+  }
+
+  // Update System Stack Pointer with the appropriate XPLINK stack bias.
+  __ lay(r4, MemOperand(sp, -kStackPointerBias));
+
+  // Preserve r7 by placing into callee-saved register r13
+  __ mov(r13, r7);
+
+  // Load function pointer from slot 1 of fn desc.
+  __ LoadU64(ip, MemOperand(scratch, kSystemPointerSize));
+  // Load environment from slot 0 of fn desc.
+  __ LoadU64(r5, MemOperand(scratch, 0));
+
+  __ StoreReturnAddressAndCall(ip);
+
+  // Restore r7 from r13
+  __ mov(r7, r13);
+}
+#endif  // V8_OS_ZOS
+
 // Calls an API function.  Allocates HandleScope, extracts returned value
 // from handle and propagates exceptions.  Restores context.  On return removes
 // *stack_space_operand * kSystemPointerSize or stack_space * kSystemPointerSize
@@ -6421,13 +6555,21 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, bool with_profiling,
       ER::handle_scope_level_address(isolate), no_reg);
 
   Register return_value = r2;
+#if V8_OS_ZOS
+  Register scratch = r8;
+#else
   Register scratch = ip;
+#endif
   Register scratch2 = r1;
 
   // Allocate HandleScope in callee-saved registers.
   // We will need to restore the HandleScope after the call to the API function,
   // by allocating it in callee-saved registers it'll be preserved by C code.
+#if V8_OS_ZOS
+  Register prev_next_address_reg = r14;
+#else
   Register prev_next_address_reg = r6;
+#endif
   Register prev_limit_reg = r7;
   Register prev_level_reg = r8;
 
@@ -6471,7 +6613,12 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, bool with_profiling,
   }
 
   __ RecordComment("Call the api function directly.");
+#if V8_OS_ZOS
+  __ mov(scratch, function_address);
+  zosStoreReturnAddressAndCall(masm, function_address, scratch);
+#else
   __ StoreReturnAddressAndCall(function_address);
+#endif
   __ bind(&done_api_call);
 
   Label promote_scheduled_exception;
@@ -6543,7 +6690,11 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, bool with_profiling,
         ER::api_callback_thunk_argument_address(isolate), no_reg);
     __ StoreU64(thunk_arg, thunk_arg_mem_op);
     __ Move(scratch, thunk_ref);
+#if V8_OS_ZOS
+    zosStoreReturnAddressAndCall(masm, function_address, scratch);
+#else
     __ StoreReturnAddressAndCall(scratch);
+#endif
     __ b(&done_api_call);
   }
 
diff --git a/src/codegen/s390/macro-assembler-s390.h b/src/codegen/s390/macro-assembler-s390.h
index b261b7b56d9..df2312ec2a2 100644
--- a/src/codegen/s390/macro-assembler-s390.h
+++ b/src/codegen/s390/macro-assembler-s390.h
@@ -931,16 +931,20 @@ class V8_EXPORT_PRIVATE MacroAssembler : public MacroAssemblerBase {
   };
   void CallCFunction(
       ExternalReference function, int num_arguments,
+      bool has_function_descriptor = ABI_USES_FUNCTION_DESCRIPTORS,
       SetIsolateDataSlots set_isolate_data_slots = SetIsolateDataSlots::kYes);
   void CallCFunction(
       Register function, int num_arguments,
+      bool has_function_descriptor = ABI_USES_FUNCTION_DESCRIPTORS,
       SetIsolateDataSlots set_isolate_data_slots = SetIsolateDataSlots::kYes);
   void CallCFunction(
       ExternalReference function, int num_reg_arguments,
       int num_double_arguments,
+      bool has_function_descriptor = ABI_USES_FUNCTION_DESCRIPTORS,
       SetIsolateDataSlots set_isolate_data_slots = SetIsolateDataSlots::kYes);
   void CallCFunction(
       Register function, int num_reg_arguments, int num_double_arguments,
+      bool has_function_descriptor = ABI_USES_FUNCTION_DESCRIPTORS,
       SetIsolateDataSlots set_isolate_data_slots = SetIsolateDataSlots::kYes);
 
   void MovFromFloatParameter(DoubleRegister dst);
diff --git a/src/codegen/s390/register-s390.h b/src/codegen/s390/register-s390.h
index a53df8d2aa6..818be504510 100644
--- a/src/codegen/s390/register-s390.h
+++ b/src/codegen/s390/register-s390.h
@@ -48,7 +48,47 @@ namespace internal {
 // The following constants describe the stack frame linkage area as
 // defined by the ABI.
 
-#if V8_TARGET_ARCH_S390X
+#if V8_OS_ZOS && V8_TARGET_ARCH_S390X
+// z/OS XPLINK 64-bit frame shape (without the 2k stack bias):
+// [0] Backchain
+// [1] Environment
+// [2] Entry Point
+// [3] Return Address (XPLINK)
+// [4] GPR8
+// [5] GPR9
+// ...
+// [10] GPR14 / RA Slot
+// [11] GPR15 / SP Slot
+// [12] Reserved
+// [13] Reserved
+// [14] Debug Area
+// [15] Reserved
+// [16] Register Arg1
+// [17] Register Arg2
+// [18] Register Arg3
+// [19] Register Arg4
+// [20] Register Arg5
+
+// Since z/OS port of V8 follows the register assignment from Linux in the
+// JavaScript context, JS code will set up r2-r6 as parameter registers,
+// with 6th+ parameters passed on the stack, when calling C functions.
+// XPLINK allocates stack slots for all parameters regardless of whether
+// they are passed in registers.  To ensure stack slots are available to
+// store register parameters back to the stack for XPLINK calls, we include
+// slots for the 5 "register" arguments (r2-r6 as noted above) as part of
+// the required stack frame slots.  Additional params being passed on the
+// stack will continue to grow from slot 22 and beyond.
+//
+// The 2k stack bias for XPLINK will be adjusted from SP into r4 (system
+// stack pointer) by the CallCFunctionHelper and CEntryStub right before
+// the actual native call.
+const int kNumRequiredStackFrameSlots = 21;
+const int kStackFrameSPSlot = 11;
+const int kStackFrameRASlot = 10;
+const int kStackFrameExtraParamSlot = 21;
+const int kXPLINKStackFrameExtraParamSlot = 19;
+const int kStackPointerBias = 2048;
+#elif V8_TARGET_ARCH_S390X
 // [0] Back Chain
 // [1] Reserved for compiler use
 // [2] GPR 2
diff --git a/src/common/assert-scope.cc b/src/common/assert-scope.cc
index 1b996b14e49..e208335fc64 100644
--- a/src/common/assert-scope.cc
+++ b/src/common/assert-scope.cc
@@ -23,7 +23,14 @@ template <PerThreadAssertType kType>
 using PerThreadDataBit = base::BitField<bool, kType, 1>;
 
 // Thread-local storage for assert data.
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<uint32_t> __current_per_thread_ad_impl(kInitialValue);
+#define current_per_thread_assert_data (*__current_per_thread_ad_impl.access())
+#else
 thread_local uint32_t current_per_thread_assert_data(kInitialValue);
+#endif
 
 }  // namespace
 
diff --git a/src/common/globals.h b/src/common/globals.h
index da61b9c33d0..ceb31142973 100644
--- a/src/common/globals.h
+++ b/src/common/globals.h
@@ -154,6 +154,10 @@ namespace internal {
 //    initializing V8 we already have a large stack and so have to set the
 //    limit lower. See issue crbug.com/v8/10575
 #define V8_DEFAULT_STACK_SIZE_KB 864
+#elif V8_OS_ZOS
+// z/OS XPLINK allocates 1MB for the stack, add 1MB due to large frames:
+// https://www.ibm.com/docs/en/zos/2.3.0?topic=stack-xplink-frame-layout
+#define V8_DEFAULT_STACK_SIZE_KB 2048
 #elif V8_TARGET_ARCH_IA32
 // In mid-2022, we're observing an increase in stack overflow crashes on
 // 32-bit Windows; the suspicion is that some third-party software suddenly
@@ -196,9 +200,12 @@ constexpr int kStackSpaceRequiredForCompilation = 40;
 constexpr int kStackLimitSlackForDeoptimizationInBytes = 256;
 
 // Sanity-check, assuming that we aim for a real OS stack size of at least 1MB.
+// On z/OS, >1MB of stack size is used.
+#if !V8_OS_ZOS
 static_assert(V8_DEFAULT_STACK_SIZE_KB * KB +
                   kStackLimitSlackForDeoptimizationInBytes <=
               MB);
+#endif
 
 // The V8_ENABLE_NEAR_CODE_RANGE_BOOL enables logic that tries to allocate
 // code range within a pc-relative call/jump proximity from embedded builtins.
diff --git a/src/common/ptr-compr.h b/src/common/ptr-compr.h
index c60e66eca50..46e3d4c995e 100644
--- a/src/common/ptr-compr.h
+++ b/src/common/ptr-compr.h
@@ -60,6 +60,10 @@ class V8HeapCompressionScheme {
 
 #ifdef V8_COMPRESS_POINTERS_IN_SHARED_CAGE
   static V8_EXPORT_PRIVATE uintptr_t base_ V8_CONSTINIT;
+#elif V8_OS_ZOS
+  [[clang::no_destroy]]
+  static __tlssim<uintptr_t> __base_impl;
+  #define base_ (*__base_impl.access())
 #else
   static thread_local uintptr_t base_ V8_CONSTINIT;
 #endif  // V8_COMPRESS_POINTERS_IN_SHARED_CAGE
@@ -111,6 +115,10 @@ class ExternalCodeCompressionScheme {
 
 #ifdef V8_COMPRESS_POINTERS_IN_SHARED_CAGE
   static V8_EXPORT_PRIVATE uintptr_t base_ V8_CONSTINIT;
+#elif V8_OS_ZOS
+  [[clang::no_destroy]]
+  static __tlssim<uintptr_t> __base_impl;
+  #define base_ (*__base_impl.access())
 #else
   static thread_local uintptr_t base_ V8_CONSTINIT;
 #endif  // V8_COMPRESS_POINTERS_IN_SHARED_CAGE
diff --git a/src/compiler/backend/s390/code-generator-s390.cc b/src/compiler/backend/s390/code-generator-s390.cc
index 241014d1f23..ddb1f755648 100644
--- a/src/compiler/backend/s390/code-generator-s390.cc
+++ b/src/compiler/backend/s390/code-generator-s390.cc
@@ -1296,8 +1296,17 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       break;
     case kArchCallCFunction: {
       int const num_gp_parameters = ParamField::decode(instr->opcode());
-      int const num_fp_parameters = FPParamField::decode(instr->opcode());
+      int const fp_param_field = FPParamField::decode(instr->opcode());
+      int num_fp_parameters = fp_param_field;
       Label return_location;
+      bool has_function_descriptor = false;
+
+#if ABI_USES_FUNCTION_DESCRIPTORS
+      int kNumFPParametersMask = kHasFunctionDescriptorBitMask - 1;
+      num_fp_parameters = kNumFPParametersMask & fp_param_field;
+      has_function_descriptor =
+          (fp_param_field & kHasFunctionDescriptorBitMask) != 0;
+#endif
       // Put the return address in a stack slot.
 #if V8_ENABLE_WEBASSEMBLY
       if (linkage()->GetIncomingDescriptor()->IsWasmCapiFunction()) {
@@ -1309,10 +1318,12 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
 #endif  // V8_ENABLE_WEBASSEMBLY
       if (instr->InputAt(0)->IsImmediate()) {
         ExternalReference ref = i.InputExternalReference(0);
-        __ CallCFunction(ref, num_gp_parameters, num_fp_parameters);
+        __ CallCFunction(ref, num_gp_parameters, num_fp_parameters,
+                         has_function_descriptor);
       } else {
         Register func = i.InputRegister(0);
-        __ CallCFunction(func, num_gp_parameters, num_fp_parameters);
+        __ CallCFunction(func, num_gp_parameters, num_fp_parameters,
+                         has_function_descriptor);
       }
       __ bind(&return_location);
 #if V8_ENABLE_WEBASSEMBLY
diff --git a/src/compiler/code-assembler.h b/src/compiler/code-assembler.h
index 2c56623c158..862775059f9 100644
--- a/src/compiler/code-assembler.h
+++ b/src/compiler/code-assembler.h
@@ -1331,7 +1331,7 @@ class V8_EXPORT_PRIVATE CodeAssembler {
     return CallCFunction(function, return_type, {cargs...});
   }
 
-  // Call to a C function without a function discriptor on AIX.
+  // Call to a C function without a function discriptor on AIX and z/OS.
   template <class... CArgs>
   Node* CallCFunctionWithoutFunctionDescriptor(Node* function,
                                                MachineType return_type,
diff --git a/src/compiler/js-heap-broker.cc b/src/compiler/js-heap-broker.cc
index 804e9a7ceb6..0e62618c848 100644
--- a/src/compiler/js-heap-broker.cc
+++ b/src/compiler/js-heap-broker.cc
@@ -63,7 +63,14 @@ std::string JSHeapBroker::Trace() const {
 }
 
 #ifdef DEBUG
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+static __tlssim<JSHeapBroker*> __current_broker_impl(nullptr);
+#define current_broker (*__current_broker_impl.access())
+#else
 static thread_local JSHeapBroker* current_broker = nullptr;
+#endif
 
 CurrentHeapBrokerScope::CurrentHeapBrokerScope(JSHeapBroker* broker)
     : prev_broker_(current_broker) {
diff --git a/src/compiler/linkage.h b/src/compiler/linkage.h
index 672c4a68fa1..ea833becc1e 100644
--- a/src/compiler/linkage.h
+++ b/src/compiler/linkage.h
@@ -89,8 +89,8 @@ class V8_EXPORT_PRIVATE CallDescriptor final
     // frame construction.
     kIsTailCallForTierUp = 1u << 8,
 
-    // AIX has a function descriptor by default but it can be disabled for a
-    // certain CFunction call (only used for Kind::kCallAddress).
+    // AIX and z/OS have a function descriptor by default but it can be disabled
+    // for a certain CFunction call (only used for Kind::kCallAddress).
     kNoFunctionDescriptor = 1u << 9,
 
     // Flags past here are *not* encoded in InstructionCode and are thus not
diff --git a/src/compiler/node-matchers.h b/src/compiler/node-matchers.h
index 6857a771c60..1057c81d875 100644
--- a/src/compiler/node-matchers.h
+++ b/src/compiler/node-matchers.h
@@ -20,6 +20,12 @@
 #include "src/compiler/operator.h"
 #include "src/objects/heap-object.h"
 
+#if V8_OS_ZOS
+// TODO(gabylb): zos - This conflicts with base_ def'n in ptr-compr.h
+// thread_local workaroud.
+#undef base_
+#endif
+
 namespace v8 {
 namespace internal {
 namespace compiler {
diff --git a/src/compiler/raw-machine-assembler.h b/src/compiler/raw-machine-assembler.h
index 3bded2ebdcf..dffd994e7a6 100644
--- a/src/compiler/raw-machine-assembler.h
+++ b/src/compiler/raw-machine-assembler.h
@@ -1028,7 +1028,7 @@ class V8_EXPORT_PRIVATE RawMachineAssembler {
   Node* CallCFunction(Node* function, base::Optional<MachineType> return_type,
                       std::initializer_list<CFunctionArg> args);
 
-  // Call to a C function without a function discriptor on AIX.
+  // Call to a C function without a function discriptor on AIX and z/OS.
   template <class... CArgs>
   Node* CallCFunctionWithoutFunctionDescriptor(Node* function,
                                                MachineType return_type,
diff --git a/src/compiler/turboshaft/memory-optimization-reducer.h b/src/compiler/turboshaft/memory-optimization-reducer.h
index 02203b40171..17b5203c493 100644
--- a/src/compiler/turboshaft/memory-optimization-reducer.h
+++ b/src/compiler/turboshaft/memory-optimization-reducer.h
@@ -15,6 +15,12 @@
 #include "src/compiler/write-barrier-kind.h"
 #include "src/zone/zone-containers.h"
 
+// TODO(gabylb): zos - conflicts with top_ from contextual.h;
+// undo when thread_local is supported.
+#ifdef V8_OS_ZOS
+#undef top_
+#endif
+
 namespace v8::internal::compiler::turboshaft {
 
 #include "src/compiler/turboshaft/define-assembler-macros.inc"
diff --git a/src/d8/d8-posix.cc b/src/d8/d8-posix.cc
index 6b53da110bd..0c25940abfb 100644
--- a/src/d8/d8-posix.cc
+++ b/src/d8/d8-posix.cc
@@ -4,7 +4,9 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#ifndef __MVS__
 #include <netinet/ip.h>
+#endif
 #include <signal.h>
 #include <stdlib.h>
 #include <string.h>
diff --git a/src/d8/d8-test.cc b/src/d8/d8-test.cc
index 37ce785cc6f..7374440dc6c 100644
--- a/src/d8/d8-test.cc
+++ b/src/d8/d8-test.cc
@@ -1416,7 +1416,14 @@ class FastCApiObject {
 
 // The object is statically initialized for simplicity, typically the embedder
 // will take care of managing their C++ objects lifetime.
+#ifdef __MVS__
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<FastCApiObject> __kFastCApiObject_impl;
+#define kFastCApiObject (*__kFastCApiObject_impl.access())
+#else
 thread_local FastCApiObject kFastCApiObject;
+#endif
 }  // namespace
 
 // static
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index edd3feea816..f9d90393c07 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -125,7 +125,13 @@ namespace v8 {
 namespace {
 
 // Set on worker threads to the current Worker instance.
+#if V8_OS_ZOS
+[[clang::no_destroy]]
+__tlssim<Worker*> __current_worker_impl(nullptr);
+#define current_worker_ (*__current_worker_impl.access())
+#else
 thread_local Worker* current_worker_ = nullptr;
+#endif
 
 #ifdef V8_FUZZILLI
 // REPRL = read-eval-print-reset-loop
@@ -5761,6 +5767,7 @@ void d8_install_sigterm_handler() {
 #ifdef V8_OS_POSIX
   CHECK(!i::v8_flags.fuzzing);
   struct sigaction sa;
+  memset(&sa, 0, sizeof(sa));
   sa.sa_sigaction = d8_sigterm_handler;
   sigemptyset(&sa.sa_mask);
   sa.sa_flags = 0;
diff --git a/src/diagnostics/objects-debug.cc b/src/diagnostics/objects-debug.cc
index 57c428cb4e7..c78a5a0cdbd 100644
--- a/src/diagnostics/objects-debug.cc
+++ b/src/diagnostics/objects-debug.cc
@@ -1368,11 +1368,12 @@ void InstructionStream::InstructionStreamVerify(Isolate* isolate) {
   CHECK(
       IsAligned(code->instruction_size(),
                 static_cast<unsigned>(InstructionStream::kMetadataAlignment)));
-#if !defined(_MSC_VER) || defined(__clang__)
-  // See also: PlatformEmbeddedFileWriterWin::AlignToCodeAlignment.
+#if (!defined(_MSC_VER) || defined(__clang__)) && !defined(V8_OS_ZOS)
+  // See also: PlatformEmbeddedFileWriterWin::AlignToCodeAlignment
+  //      and: PlatformEmbeddedFileWriterZOS::AlignToCodeAlignment.
   CHECK_IMPLIES(!ReadOnlyHeap::Contains(*this),
                 IsAligned(instruction_start(), kCodeAlignment));
-#endif  // !defined(_MSC_VER) || defined(__clang__)
+#endif  // (!defined(_MSC_VER) || defined(__clang__)) && !defined(V8_OS_ZOS)
   CHECK_IMPLIES(!ReadOnlyHeap::Contains(*this),
                 IsAligned(instruction_start(), kCodeAlignment));
   CHECK_EQ(*this, code->instruction_stream());
diff --git a/src/execution/execution.cc b/src/execution/execution.cc
index 3db649f4cdb..b5411ae5174 100644
--- a/src/execution/execution.cc
+++ b/src/execution/execution.cc
@@ -423,9 +423,16 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> Invoke(Isolate* isolate,
       Address recv = (*params.receiver).ptr();
       Address** argv = reinterpret_cast<Address**>(params.argv);
       RCS_SCOPE(isolate, RuntimeCallCounterId::kJS_Execution);
+#if V8_OS_ZOS
+      void *new_sp[1];
+      LESavStackAsync::getInstance().save(new_sp); // from zoslib
+#endif
       value = Tagged<Object>(
           stub_entry.Call(isolate->isolate_data()->isolate_root(), orig_func,
                           func, recv, JSParameterCount(params.argc), argv));
+#if V8_OS_ZOS
+      LESavStackAsync::getInstance().restore();
+#endif
     } else {
       DCHECK_EQ(Execution::Target::kRunMicrotasks, params.execution_target);
 
diff --git a/src/execution/frames.h b/src/execution/frames.h
index 8f62ba5f56c..1a4eee62ec1 100644
--- a/src/execution/frames.h
+++ b/src/execution/frames.h
@@ -20,6 +20,12 @@
 #include "src/wasm/wasm-code-manager.h"
 #endif  // V8_ENABLE_WEBASSEMBLY
 
+#if V8_OS_ZOS
+// TODO(gabylb): zos - This conflicts with base_ def'n in ptr-compr.h
+// thread_local workaroud.
+#undef base_
+#endif
+
 //
 // Frame inheritance hierarchy (please keep in sync with frame-constants.h):
 // - CommonFrame
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index bb3c73cf39b..95cc54e7f72 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -489,9 +489,20 @@ size_t Isolate::HashIsolateForEmbeddedBlob() {
 
 Isolate* Isolate::process_wide_shared_space_isolate_{nullptr};
 
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<Isolate::PerIsolateThreadData*> g_current_per_isolate_thread_data_impl(nullptr);
+#define g_current_per_isolate_thread_data_ (*g_current_per_isolate_thread_data_impl.access())
+
+[[clang::no_destroy]]
+__tlssim<Isolate*> g_current_isolate_impl(nullptr);
+#define g_current_isolate_ (*g_current_isolate_impl.access())
+#else
 thread_local Isolate::PerIsolateThreadData* g_current_per_isolate_thread_data_
     V8_CONSTINIT = nullptr;
 thread_local Isolate* g_current_isolate_ V8_CONSTINIT = nullptr;
+#endif
 
 namespace {
 // A global counter for all generated Isolates, might overflow.
@@ -1629,9 +1640,12 @@ Tagged<Object> Isolate::StackOverflow() {
   // frames until we reach this method.
   // If this DCHECK fails, one of the frames on the stack should be augmented by
   // an additional stack check.
-#if defined(V8_USE_ADDRESS_SANITIZER) || defined(MEMORY_SANITIZER)
+#if defined(V8_USE_ADDRESS_SANITIZER) || defined(MEMORY_SANITIZER) || \
+    defined(V8_OS_ZOS)
   // Allow for a bit more overflow in sanitizer builds, because C++ frames take
   // significantly more space there.
+  // z/OS XPLINK uses larger frames:
+  // https://www.ibm.com/docs/en/zos/2.3.0?topic=stack-xplink-frame-layout
   DCHECK_GE(GetCurrentStackPosition(), stack_guard()->real_climit() - 64 * KB);
 #else
   DCHECK_GE(GetCurrentStackPosition(), stack_guard()->real_climit() - 8 * KB);
@@ -4700,6 +4714,16 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
     // using one thread.
     ExecutionAccess lock(this);
     stack_guard()->InitThread(lock);
+#if V8_OS_ZOS
+    // This is required because even though setting the initial stack size via
+    // runtime options STACK64 or THREADSTACK64 works, the runtime option
+    // RPTSTG(ON), if used, resets the initial stack size to 1M, and LE
+    // doesn't always automatically expand the stack in JS code.
+    volatile char buf[v8_flags.stack_size*KB];
+    // For clang, this is needed unless compiled with -O0 or
+    // -ftrivial-auto-var-init=pattern if -O3:
+    *buf = 0;
+#endif
   }
 
   // Create LocalIsolate/LocalHeap for the main thread and set state to Running.
diff --git a/src/execution/isolate.h b/src/execution/isolate.h
index 9411549f73f..f9acdfc46bb 100644
--- a/src/execution/isolate.h
+++ b/src/execution/isolate.h
@@ -2721,9 +2721,18 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
 // These are outside the Isolate class with extern storage because in clang-cl,
 // thread_local is incompatible with dllexport linkage caused by
 // V8_EXPORT_PRIVATE being applied to Isolate.
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+extern __tlssim<Isolate::PerIsolateThreadData*> g_current_per_isolate_thread_data_impl;
+#define g_current_per_isolate_thread_data_ (*g_current_per_isolate_thread_data_impl.access())
+
+extern __tlssim<Isolate*> g_current_isolate_impl;
+#define g_current_isolate_ (*g_current_isolate_impl.access())
+#else
 extern thread_local Isolate::PerIsolateThreadData*
     g_current_per_isolate_thread_data_ V8_CONSTINIT;
 extern thread_local Isolate* g_current_isolate_ V8_CONSTINIT;
+#endif
 
 #undef FIELD_ACCESSOR
 #undef THREAD_LOCAL_TOP_ACCESSOR
diff --git a/src/execution/simulator.h b/src/execution/simulator.h
index 07495a148ec..f31489f7f52 100644
--- a/src/execution/simulator.h
+++ b/src/execution/simulator.h
@@ -165,6 +165,23 @@ class GeneratedCode {
     FATAL("Generated code execution not possible during cross-compilation.");
 #endif  // defined(V8_TARGET_OS_WIN) && !defined(V8_OS_WIN)
 #if ABI_USES_FUNCTION_DESCRIPTORS
+#if V8_OS_ZOS
+    // z/OS ABI requires function descriptors (FD). Artificially create a pseudo
+    // FD to ensure correct dispatch to generated code.  The 'volatile'
+    // declaration is required to avoid the compiler from not observing the
+    // alias of the pseudo FD to the function pointer, and hence, optimizing the
+    // pseudo FD declaration/initialization away.
+    volatile void* function_desc[2];
+    // TODO(alexy): zos - the order of the following 2 line is important as it
+    // is a workaround to a compiler bug that when compile with qNOEH option, it
+    // will execute the following line after calling the function if the inline
+    // asm run before assigning fn_ptr_, revisit when clang compiler is
+    // available on z/OS.
+    function_desc[1] = reinterpret_cast<void*>(fn_ptr_);
+    asm volatile(" stg 5,%0 " : "=m"(function_desc[0]) : : "r5");
+    Signature* fn = reinterpret_cast<Signature*>(&function_desc[0]);
+    return fn(args...);
+#else
     // AIX ABI requires function descriptors (FD).  Artificially create a pseudo
     // FD to ensure correct dispatch to generated code.  The 'volatile'
     // declaration is required to avoid the compiler from not observing the
@@ -174,6 +191,7 @@ class GeneratedCode {
                                         0};
     Signature* fn = reinterpret_cast<Signature*>(function_desc);
     return fn(args...);
+#endif  // V8_OS_ZOS
 #else
     return fn_ptr_(args...);
 #endif  // ABI_USES_FUNCTION_DESCRIPTORS
diff --git a/src/execution/thread-id.cc b/src/execution/thread-id.cc
index ec4e95ad5d8..66d8e218da4 100644
--- a/src/execution/thread-id.cc
+++ b/src/execution/thread-id.cc
@@ -11,7 +11,14 @@ namespace internal {
 
 namespace {
 
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<int> __thread_id_impl(0);
+#define thread_id (*__thread_id_impl.access())
+#else
 thread_local int thread_id = 0;
+#endif
 
 std::atomic<int> next_thread_id{1};
 
diff --git a/src/heap/base/worklist.h b/src/heap/base/worklist.h
index 3834b7cb3bc..193b067e63f 100644
--- a/src/heap/base/worklist.h
+++ b/src/heap/base/worklist.h
@@ -13,6 +13,12 @@
 #include "src/base/platform/memory.h"
 #include "src/base/platform/mutex.h"
 
+#ifdef V8_OS_ZOS
+// TODO(gabylb): zos - conflicts with top_ in contextual.h;
+// undo when thread_local is supported.
+#undef top_
+#endif
+
 namespace heap::base {
 namespace internal {
 
diff --git a/src/heap/heap-verifier.cc b/src/heap/heap-verifier.cc
index bd16c4f7ed0..938b66f68c8 100644
--- a/src/heap/heap-verifier.cc
+++ b/src/heap/heap-verifier.cc
@@ -35,8 +35,21 @@ namespace v8 {
 namespace internal {
 
 namespace {
+#if V8_OS_ZOS
+// TODO(gabylb): zos - this is enabled only in a debug build
+// and fails to compile:
+#if 0
+[[clang::no_destroy]]
+__tlssim<HeapObject> __pending_layout_change_object_impl(Tagged<HeapObject>());
+#define pending_layout_change_object (*__pending_layout_change_object_impl.access())
+#else
+Tagged<HeapObject> pending_layout_change_object =
+    Tagged<HeapObject>();
+#endif
+#else
 thread_local Tagged<HeapObject> pending_layout_change_object =
     Tagged<HeapObject>();
+#endif
 }  // namespace
 
 // Verify that all objects are Smis.
diff --git a/src/heap/heap-write-barrier.cc b/src/heap/heap-write-barrier.cc
index 909e2f1443d..68585296484 100644
--- a/src/heap/heap-write-barrier.cc
+++ b/src/heap/heap-write-barrier.cc
@@ -17,7 +17,14 @@ namespace v8 {
 namespace internal {
 
 namespace {
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<MarkingBarrier*> __current_marking_barrier_impl(nullptr);
+#define current_marking_barrier (*__current_marking_barrier_impl.access())
+#else
 thread_local MarkingBarrier* current_marking_barrier = nullptr;
+#endif
 }  // namespace
 
 MarkingBarrier* WriteBarrier::CurrentMarkingBarrier(
diff --git a/src/heap/heap.cc b/src/heap/heap.cc
index 53ad33596b0..84ab286c18b 100644
--- a/src/heap/heap.cc
+++ b/src/heap/heap.cc
@@ -3895,7 +3895,13 @@ void Heap::InvokeIncrementalMarkingEpilogueCallbacks() {
 }
 
 namespace {
+#if V8_OS_ZOS
+[[clang::no_destroy]]
+__tlssim<Address> __pending_layout_change_object_address_impl(kNullAddress);
+#define pending_layout_change_object_address (*__pending_layout_change_object_address_impl.access())
+#else
 thread_local Address pending_layout_change_object_address = kNullAddress;
+#endif
 
 #ifdef V8_ENABLE_SANDBOX
 class ExternalPointerSlotInvalidator : public ObjectVisitor {
diff --git a/src/heap/large-spaces.cc b/src/heap/large-spaces.cc
index 02d302d891f..47f46dbd82e 100644
--- a/src/heap/large-spaces.cc
+++ b/src/heap/large-spaces.cc
@@ -221,6 +221,11 @@ void LargeObjectSpace::RemovePage(LargePage* page) {
 void LargeObjectSpace::ShrinkPageToObjectSize(LargePage* page,
                                               Tagged<HeapObject> object,
                                               size_t object_size) {
+#if V8_OS_ZOS
+  // TODO(gabylb): zos - z/OS does not allow partial frees, remove after
+  // switch to use mmap() which currently doesn't support MAP_ANONYMOUS.
+  return;
+#endif
 #ifdef DEBUG
   PtrComprCageBase cage_base(heap()->isolate());
   DCHECK_EQ(object, page->GetObject());
diff --git a/src/heap/linear-allocation-area.h b/src/heap/linear-allocation-area.h
index 7b8c9c04490..8b7cf10c4aa 100644
--- a/src/heap/linear-allocation-area.h
+++ b/src/heap/linear-allocation-area.h
@@ -10,6 +10,12 @@
 #include "include/v8-internal.h"
 #include "src/common/checks.h"
 
+// TODO(gabylb) - zos: conflicts with top_ from contextual.h;
+// undo when thread_local is supported.
+#ifdef V8_OS_ZOS
+#undef top_
+#endif
+
 namespace v8 {
 namespace internal {
 
diff --git a/src/heap/local-heap.cc b/src/heap/local-heap.cc
index 45567f58571..c6d0f643430 100644
--- a/src/heap/local-heap.cc
+++ b/src/heap/local-heap.cc
@@ -30,7 +30,13 @@ namespace v8 {
 namespace internal {
 
 namespace {
+#if V8_OS_ZOS
+[[clang::no_destroy]]
+__tlssim<LocalHeap*> __current_local_heap_impl(nullptr);
+#define current_local_heap (*__current_local_heap_impl.access())
+#else
 thread_local LocalHeap* current_local_heap = nullptr;
+#endif
 }  // namespace
 
 LocalHeap* LocalHeap::Current() { return current_local_heap; }
diff --git a/src/libsampler/sampler.cc b/src/libsampler/sampler.cc
index acb9db8e17c..9a02c48420e 100644
--- a/src/libsampler/sampler.cc
+++ b/src/libsampler/sampler.cc
@@ -16,7 +16,7 @@
 #include <sys/time.h>
 #include <atomic>
 
-#if !V8_OS_QNX && !V8_OS_AIX
+#if !V8_OS_QNX && !V8_OS_AIX && !V8_OS_ZOS
 #include <sys/syscall.h>
 #endif
 
@@ -70,6 +70,19 @@ using zx_thread_state_general_regs_t = zx_arm64_general_regs_t;
 #include "src/base/atomic-utils.h"
 #include "src/base/platform/platform.h"
 
+#if V8_OS_ZOS
+// Header from zoslib, for __mcontext_t_:
+#include "edcwccwi.h"
+
+inline int ThreadKey(pthread_t& thread_id) {
+  return static_cast<int>(thread_id.__ & 0x7fffffff);
+}
+#else
+inline pthread_t ThreadKey(pthread_t& thread_id) {
+  return thread_id;
+}
+#endif
+
 #if V8_OS_ANDROID && !defined(__BIONIC_HAVE_UCONTEXT_T)
 
 // Not all versions of Android's C library provide ucontext_t.
@@ -208,11 +221,11 @@ void SamplerManager::AddSampler(Sampler* sampler) {
   AtomicGuard atomic_guard(&samplers_access_counter_);
   DCHECK(sampler->IsActive());
   pthread_t thread_id = sampler->platform_data()->vm_tid();
-  auto it = sampler_map_.find(thread_id);
+  auto it = sampler_map_.find(ThreadKey(thread_id));
   if (it == sampler_map_.end()) {
     SamplerList samplers;
     samplers.push_back(sampler);
-    sampler_map_.emplace(thread_id, std::move(samplers));
+    sampler_map_.emplace(ThreadKey(thread_id), std::move(samplers));
   } else {
     SamplerList& samplers = it->second;
     auto sampler_it = std::find(samplers.begin(), samplers.end(), sampler);
@@ -224,7 +237,7 @@ void SamplerManager::RemoveSampler(Sampler* sampler) {
   AtomicGuard atomic_guard(&samplers_access_counter_);
   DCHECK(sampler->IsActive());
   pthread_t thread_id = sampler->platform_data()->vm_tid();
-  auto it = sampler_map_.find(thread_id);
+  auto it = sampler_map_.find(ThreadKey(thread_id));
   DCHECK_NE(it, sampler_map_.end());
   SamplerList& samplers = it->second;
   samplers.erase(std::remove(samplers.begin(), samplers.end(), sampler),
@@ -239,7 +252,7 @@ void SamplerManager::DoSample(const v8::RegisterState& state) {
   // TODO(petermarshall): Add stat counters for the bailouts here.
   if (!atomic_guard.is_success()) return;
   pthread_t thread_id = pthread_self();
-  auto it = sampler_map_.find(thread_id);
+  auto it = sampler_map_.find(ThreadKey(thread_id));
   if (it == sampler_map_.end()) return;
   SamplerList& samplers = it->second;
 
@@ -392,10 +405,12 @@ void SignalHandler::HandleProfilerSignal(int signal, siginfo_t* info,
 void SignalHandler::FillRegisterState(void* context, RegisterState* state) {
   // Extracting the sample from the context is extremely machine dependent.
   ucontext_t* ucontext = reinterpret_cast<ucontext_t*>(context);
-#if !(V8_OS_OPENBSD || \
+#if !(V8_OS_OPENBSD || V8_OS_ZOS || \
       (V8_OS_LINUX &&  \
        (V8_HOST_ARCH_PPC || V8_HOST_ARCH_S390 || V8_HOST_ARCH_PPC64)))
   mcontext_t& mcontext = ucontext->uc_mcontext;
+#elif V8_OS_ZOS
+  __mcontext_t_* mcontext = reinterpret_cast<__mcontext_t_*>(context);
 #endif
 #if V8_OS_LINUX
 #if V8_HOST_ARCH_IA32
@@ -467,6 +482,12 @@ void SignalHandler::FillRegisterState(void* context, RegisterState* state) {
   state->fp = reinterpret_cast<void*>(mcontext.__gregs[REG_S0]);
   state->lr = reinterpret_cast<void*>(mcontext.__gregs[REG_RA]);
 #endif  // V8_HOST_ARCH_*
+
+#elif V8_OS_ZOS
+  state->pc = reinterpret_cast<void*>(mcontext->__mc_psw);
+  state->sp = reinterpret_cast<void*>(mcontext->__mc_gr[15]);
+  state->fp = reinterpret_cast<void*>(mcontext->__mc_gr[11]);
+  state->lr = reinterpret_cast<void*>(mcontext->__mc_gr[14]);
 #elif V8_OS_IOS
 
 #if V8_TARGET_ARCH_ARM64
diff --git a/src/libsampler/sampler.h b/src/libsampler/sampler.h
index 98c06061513..5cf0e1d76de 100644
--- a/src/libsampler/sampler.h
+++ b/src/libsampler/sampler.h
@@ -151,7 +151,11 @@ class V8_EXPORT_PRIVATE SamplerManager {
   // global lazy instance.
   friend class base::LeakyObject<SamplerManager>;
 
+#if V8_OS_ZOS
+  std::unordered_map<int, SamplerList> sampler_map_;
+#else
   std::unordered_map<pthread_t, SamplerList> sampler_map_;
+#endif
   AtomicMutex samplers_access_counter_{false};
 };
 
diff --git a/src/logging/counters.cc b/src/logging/counters.cc
index 69e90957d7f..0c642c7d441 100644
--- a/src/logging/counters.cc
+++ b/src/logging/counters.cc
@@ -89,9 +89,25 @@ void TimedHistogram::RecordAbandon(base::ElapsedTimer* timer,
 
 #ifdef DEBUG
 bool TimedHistogram::ToggleRunningState(bool expect_to_run) const {
+#if V8_OS_ZOS
+#if 0
+  // TODO(gabylb): zos - __tlssim doesn't support LAZY_INSTANCE_INITIALIZER's
+  // definition.
+  [[clang::no_destroy]]
+  static __tlssim<base::LazyInstance<
+      std::unordered_map<const TimedHistogram*, bool>>::type>
+      __active_timer_impl(LAZY_INSTANCE_INITIALIZER);
+  #define active_timer (*__active_timer_impl.access())
+#else
+  static base::LazyInstance<
+      std::unordered_map<const TimedHistogram*, bool>>::type active_timer =
+      LAZY_INSTANCE_INITIALIZER;
+#endif
+#else
   static thread_local base::LazyInstance<
       std::unordered_map<const TimedHistogram*, bool>>::type active_timer =
       LAZY_INSTANCE_INITIALIZER;
+#endif
   bool is_running = (*active_timer.Pointer())[this];
   DCHECK_NE(is_running, expect_to_run);
   (*active_timer.Pointer())[this] = !is_running;
diff --git a/src/regexp/s390/regexp-macro-assembler-s390.cc b/src/regexp/s390/regexp-macro-assembler-s390.cc
index 0b0507cf546..848a5f8e257 100644
--- a/src/regexp/s390/regexp-macro-assembler-s390.cc
+++ b/src/regexp/s390/regexp-macro-assembler-s390.cc
@@ -734,11 +734,31 @@ Handle<HeapObject> RegExpMacroAssemblerS390::GetCode(Handle<String> source) {
   //    Requires us to save the callee-preserved registers r6-r13
   //    General convention is to also save r14 (return addr) and
   //    sp/r15 as well in a single STM/STMG
+#if V8_OS_ZOS
+  // Move stack down by (12*8) to save r4..r15
+  __ lay(r4, MemOperand(r4, -12 * kSystemPointerSize));
+
+  // Store r4..r15 (sp) to stack
+  __ StoreMultipleP(r4, sp, MemOperand(r4, 0));
+  __ mov(sp, r4);
+
+  // Load C args from stack to registers
+  __ LoadMultipleP(r5, r10, MemOperand(r4, (12 * kSystemPointerSize) +
+                            kStackPointerBias +
+                            (kXPLINKStackFrameExtraParamSlot *
+                            kSystemPointerSize)));
+
+  // Shuffle XPLINK input arguments to LoZ ABI registers
+  __ mov(r4, r3);
+  __ mov(r3, r2);
+  __ mov(r2, r1);
+#else
   __ StoreMultipleP(r6, sp, MemOperand(sp, 6 * kSystemPointerSize));
 
   // Load stack parameters from caller stack frame
   __ LoadMultipleP(
       r7, r9, MemOperand(sp, kStackFrameExtraParamSlot * kSystemPointerSize));
+#endif
   // r7 = capture array size
   // r8 = stack area base
   // r9 = direct call
@@ -747,6 +767,10 @@ Handle<HeapObject> RegExpMacroAssemblerS390::GetCode(Handle<String> source) {
   // Also push the frame marker.
   __ mov(r0, Operand(StackFrame::TypeToMarker(StackFrame::IRREGEXP)));
   __ push(r0);
+#if V8_OS_ZOS
+  // Store isolate address from r10 to expected stack address
+  __ StoreU64(r10, MemOperand(frame_pointer(), kIsolateOffset));
+#endif
   __ lay(sp, MemOperand(sp, -10 * kSystemPointerSize));
 
   static_assert(kSuccessfulCapturesOffset ==
@@ -1001,10 +1025,21 @@ Handle<HeapObject> RegExpMacroAssemblerS390::GetCode(Handle<String> source) {
 
   // Skip sp past regexp registers and local variables..
   __ mov(sp, frame_pointer());
+
+#if V8_OS_ZOS
+  // XPLINK uses r3 as the return register
+  __ mov(r3, r2);
+  // Restore registers r4..r15
+  __ LoadMultipleP(r4, sp, MemOperand(sp, 0));
+  // Shrink stack
+  __ lay(r4, MemOperand(r4, 12 * kSystemPointerSize));
+  __ b(r7);
+#else
   // Restore registers r6..r15.
   __ LoadMultipleP(r6, sp, MemOperand(sp, 6 * kSystemPointerSize));
 
   __ b(r14);
+#endif
 
   // Backtrack code (branch target for conditional backtracks).
   if (backtrack_label_.is_linked()) {
@@ -1226,7 +1261,39 @@ void RegExpMacroAssemblerS390::CallCheckStackGuardState(Register scratch,
       ExternalReference::re_check_stack_guard_state();
 
   __ mov(ip, Operand(stack_guard_check));
+
+#if V8_OS_ZOS
+  // Shuffle input arguments
+  __ mov(r1, r2);
+  __ mov(r2, r3);
+  __ mov(r3, r4);
+
+  // XPLINK treats r7 as voliatile return register, but r14 as preserved
+  // Since Linux is the other way around, perserve r7 value in r14 across
+  // the call.
+  __ mov(r14, r7);
+  __ StoreMultipleP(r5, r6, MemOperand(sp, 5 * kSystemPointerSize));
+
+  // Set up the system stack pointer with the XPLINK bias.
+  __ lay(r4, MemOperand(sp, -kStackPointerBias));
+
+  // Obtain code entry based on function pointer
+  __ LoadMultipleP(r5, r6, MemOperand(ip, 0));
+
+  // Call function
+  __ StoreReturnAddressAndCall(r6);
+
+  // Restore r5 and r6
+  __ LoadMultipleP(r5, r6, MemOperand(sp, 5 * kSystemPointerSize));
+
+  // Restore original r7
+  __ mov(r7, r14);
+
+  // Shuffle the result
+  __ mov(r2, r3);
+#else
   __ StoreReturnAddressAndCall(ip);
+#endif
 
   if (base::OS::ActivationFrameAlignment() > kSystemPointerSize) {
     __ LoadU64(
@@ -1362,7 +1429,7 @@ void RegExpMacroAssemblerS390::CallCFunctionFromIrregexpCode(
   //    fail.
   //
   // See also: crbug.com/v8/12670#c17.
-  __ CallCFunction(function, num_arguments,
+  __ CallCFunction(function, num_arguments, ABI_USES_FUNCTION_DESCRIPTORS,
                    MacroAssembler::SetIsolateDataSlots::kNo);
 }
 
diff --git a/src/snapshot/embedded/embedded-file-writer.cc b/src/snapshot/embedded/embedded-file-writer.cc
index 8acfacadc8b..b854c9d4f5b 100644
--- a/src/snapshot/embedded/embedded-file-writer.cc
+++ b/src/snapshot/embedded/embedded-file-writer.cc
@@ -159,6 +159,9 @@ void EmbeddedFileWriter::WriteCodeSection(PlatformEmbeddedFileWriterBase* w,
 
   w->AlignToCodeAlignment();
   w->DeclareSymbolGlobal(EmbeddedBlobCodeSymbol().c_str());
+#if V8_OS_ZOS
+  DeclareLabelProlog(w->fp(), EmbeddedBlobCodeSymbol().c_str());
+#endif
   w->DeclareLabel(EmbeddedBlobCodeSymbol().c_str());
 
   static_assert(Builtins::kAllBuiltinsAreIsolateIndependent);
@@ -168,6 +171,9 @@ void EmbeddedFileWriter::WriteCodeSection(PlatformEmbeddedFileWriterBase* w,
     WriteBuiltin(w, blob, builtin);
   }
   w->AlignToPageSizeIfNeeded();
+#if V8_OS_ZOS
+  DeclareLabelEpilogue(w->fp());
+#endif
   w->Newline();
 }
 
@@ -213,6 +219,21 @@ void EmbeddedFileWriter::WriteFileEpilogue(PlatformEmbeddedFileWriterBase* w,
 // static
 void EmbeddedFileWriter::WriteBinaryContentsAsInlineAssembly(
     PlatformEmbeddedFileWriterBase* w, const uint8_t* data, uint32_t size) {
+#if V8_OS_ZOS
+  // HLASM source must end at column 71 (followed by an optional
+  // line-continuation char on column 72), so write the binary data
+  // in 32 byte chunks (length 64):
+  uint32_t chunks = (size + 31)/32;
+  uint32_t i, j;
+  uint32_t offset = 0;
+  for (i = 0; i < chunks; ++i) {
+    fprintf(w->fp(), " DC x'");
+    for (j = 0; offset < size && j < 32; ++j) {
+       fprintf(w->fp(), "%02x", data[offset++]);
+    }
+    fprintf(w->fp(), "'\n");
+  }
+#else
   int current_line_length = 0;
   uint32_t i = 0;
 
@@ -238,6 +259,7 @@ void EmbeddedFileWriter::WriteBinaryContentsAsInlineAssembly(
   }
 
   if (current_line_length != 0) w->Newline();
+#endif  // V8_OS_ZOS
 }
 
 int EmbeddedFileWriter::LookupOrAddExternallyCompiledFilename(
diff --git a/src/snapshot/embedded/embedded-file-writer.h b/src/snapshot/embedded/embedded-file-writer.h
index 9862c402167..6af5b3300a9 100644
--- a/src/snapshot/embedded/embedded-file-writer.h
+++ b/src/snapshot/embedded/embedded-file-writer.h
@@ -23,6 +23,12 @@
 
 namespace v8 {
 namespace internal {
+
+#ifdef __MVS__
+void DeclareLabelProlog(FILE* fp, const char* name);
+void DeclareLabelEpilogue(FILE* fp);
+#endif
+
 // Generates the embedded.S file which is later compiled into the final v8
 // binary. Its contents are exported through two symbols:
 //
@@ -89,7 +95,12 @@ class EmbeddedFileWriter : public EmbeddedFileWriterInterface {
   }
 
   static FILE* GetFileDescriptorOrDie(const char* filename) {
+#ifdef __MVS__
+    // The binary mode results in an unreadable mixed mode embedded.S.
+    FILE* fp = v8::base::OS::FOpen(filename, "w");
+#else
     FILE* fp = v8::base::OS::FOpen(filename, "wb");
+#endif
     if (fp == nullptr) {
       i::PrintF("Unable to open file \"%s\" for writing.\n", filename);
       exit(1);
@@ -147,9 +158,16 @@ class EmbeddedFileWriter : public EmbeddedFileWriterInterface {
     w->SectionRoData();
     w->AlignToDataAlignment();
     w->DeclareSymbolGlobal(EmbeddedBlobDataSymbol().c_str());
+#if V8_OS_ZOS
+    DeclareLabelProlog(w->fp(), EmbeddedBlobDataSymbol().c_str());
+#endif
     w->DeclareLabel(EmbeddedBlobDataSymbol().c_str());
 
     WriteBinaryContentsAsInlineAssembly(w, blob->data(), blob->data_size());
+#if V8_OS_ZOS
+    DeclareLabelEpilogue(w->fp());
+    w->Newline();
+#endif
   }
 
   void WriteBuiltin(PlatformEmbeddedFileWriterBase* w,
diff --git a/src/snapshot/embedded/platform-embedded-file-writer-base.cc b/src/snapshot/embedded/platform-embedded-file-writer-base.cc
index e4ca7bfdacb..a73ac1461fb 100644
--- a/src/snapshot/embedded/platform-embedded-file-writer-base.cc
+++ b/src/snapshot/embedded/platform-embedded-file-writer-base.cc
@@ -11,6 +11,7 @@
 #include "src/snapshot/embedded/platform-embedded-file-writer-generic.h"
 #include "src/snapshot/embedded/platform-embedded-file-writer-mac.h"
 #include "src/snapshot/embedded/platform-embedded-file-writer-win.h"
+#include "src/snapshot/embedded/platform-embedded-file-writer-zos.h"
 
 namespace v8 {
 namespace internal {
@@ -119,6 +120,8 @@ EmbeddedTargetOs DefaultEmbeddedTargetOs() {
   return EmbeddedTargetOs::kMac;
 #elif defined(V8_OS_WIN)
   return EmbeddedTargetOs::kWin;
+#elif defined(V8_OS_ZOS)
+  return EmbeddedTargetOs::kZOS;
 #else
   return EmbeddedTargetOs::kGeneric;
 #endif
@@ -143,6 +146,8 @@ EmbeddedTargetOs ToEmbeddedTargetOs(const char* s) {
     return EmbeddedTargetOs::kWin;
   } else if (string == "starboard") {
     return EmbeddedTargetOs::kStarboard;
+  } else if (string == "zos") {
+    return EmbeddedTargetOs::kZOS;
   } else {
     return EmbeddedTargetOs::kGeneric;
   }
@@ -185,6 +190,9 @@ std::unique_ptr<PlatformEmbeddedFileWriterBase> NewPlatformEmbeddedFileWriter(
   } else if (embedded_target_os == EmbeddedTargetOs::kWin) {
     return std::make_unique<PlatformEmbeddedFileWriterWin>(embedded_target_arch,
                                                            embedded_target_os);
+  } else if (embedded_target_os == EmbeddedTargetOs::kZOS) {
+    return std::make_unique<PlatformEmbeddedFileWriterZOS>(embedded_target_arch,
+                                                           embedded_target_os);
   } else {
     return std::make_unique<PlatformEmbeddedFileWriterGeneric>(
         embedded_target_arch, embedded_target_os);
diff --git a/src/snapshot/embedded/platform-embedded-file-writer-base.h b/src/snapshot/embedded/platform-embedded-file-writer-base.h
index 4f7b98a4bed..fd06af76d02 100644
--- a/src/snapshot/embedded/platform-embedded-file-writer-base.h
+++ b/src/snapshot/embedded/platform-embedded-file-writer-base.h
@@ -31,6 +31,7 @@ enum class EmbeddedTargetOs {
   kMac,
   kWin,
   kStarboard,
+  kZOS,
   kGeneric,  // Everything not covered above falls in here.
 };
 
diff --git a/src/trap-handler/handler-shared.cc b/src/trap-handler/handler-shared.cc
index 1c6c25ce65f..dbb3dd61b46 100644
--- a/src/trap-handler/handler-shared.cc
+++ b/src/trap-handler/handler-shared.cc
@@ -26,7 +26,14 @@ namespace trap_handler {
 // We declare this as int rather than bool as a workaround for a glibc bug, in
 // which the dynamic loader cannot handle executables whose TLS area is only
 // 1 byte in size; see https://sourceware.org/bugzilla/show_bug.cgi?id=14898.
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<int> __g_thread_in_wasm_code_impl(0);
+#define g_thread_in_wasm_code (*__g_thread_in_wasm_code_impl.access())
+#else
 thread_local int g_thread_in_wasm_code;
+#endif
 
 static_assert(sizeof(g_thread_in_wasm_code) > 1,
               "sizeof(thread_local_var) must be > 1, see "
diff --git a/src/trap-handler/trap-handler.h b/src/trap-handler/trap-handler.h
index 289a755d3b1..8dfdce8b291 100644
--- a/src/trap-handler/trap-handler.h
+++ b/src/trap-handler/trap-handler.h
@@ -144,6 +144,10 @@ inline bool IsTrapHandlerEnabled() {
 // `thread_local` does not link on AIX:
 // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100641
 extern __thread int g_thread_in_wasm_code;
+#elif V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+extern __tlssim<int> __g_thread_in_wasm_code_impl;
+#define g_thread_in_wasm_code (*__g_thread_in_wasm_code_impl.access())
 #else
 extern thread_local int g_thread_in_wasm_code;
 #endif
diff --git a/src/utils/allocation.h b/src/utils/allocation.h
index c1f72ac3fe6..ce1106dd354 100644
--- a/src/utils/allocation.h
+++ b/src/utils/allocation.h
@@ -11,6 +11,12 @@
 #include "src/base/platform/memory.h"
 #include "src/init/v8.h"
 
+#if V8_OS_ZOS
+// TODO(gabylb): zos - This conflicts with base_ def'n in ptr-compr.h
+// thread_local workaroud.
+#undef base_
+#endif
+
 namespace v8 {
 
 namespace base {
diff --git a/src/wasm/wasm-code-manager.cc b/src/wasm/wasm-code-manager.cc
index 6348b45deae..83da593a26b 100644
--- a/src/wasm/wasm-code-manager.cc
+++ b/src/wasm/wasm-code-manager.cc
@@ -2559,7 +2559,14 @@ void WasmCodeManager::FlushCodeLookupCache(Isolate* isolate) {
 }
 
 namespace {
+#if V8_OS_ZOS
+// TODO(itodorov): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<WasmCodeRefScope*> __current_code_refs_scope_impl(nullptr);
+#define current_code_refs_scope (*__current_code_refs_scope_impl.access())
+#else
 thread_local WasmCodeRefScope* current_code_refs_scope = nullptr;
+#endif
 }  // namespace
 
 WasmCodeRefScope::WasmCodeRefScope()
diff --git a/test/cctest/BUILD.gn b/test/cctest/BUILD.gn
index 20af6291002..3d1a514dc5d 100644
--- a/test/cctest/BUILD.gn
+++ b/test/cctest/BUILD.gn
@@ -270,6 +270,13 @@ v8_source_set("cctest_sources") {
       ### gcmole(s390) ###
       "test-assembler-s390.cc",
     ]
+    if (current_os == "zos" && is_component_build) {
+      # for OpcodeFormatTable:
+      sources += [
+        "../../src/codegen/s390/constants-s390.h",
+        "../../src/codegen/s390/constants-s390.cc",
+      ]
+    }
   } else if (v8_current_cpu == "riscv64") {
     sources += [
       ### gcmole(riscv64) ###
diff --git a/test/cctest/cctest-utils.h b/test/cctest/cctest-utils.h
index abcd949dbe5..76dcf60b551 100644
--- a/test/cctest/cctest-utils.h
+++ b/test/cctest/cctest-utils.h
@@ -31,6 +31,9 @@ namespace internal {
 #elif V8_HOST_ARCH_MIPS64
 #define GET_STACK_POINTER_TO(sp_addr) \
   __asm__ __volatile__("sd $sp, %0" : "=g"(sp_addr))
+#elif V8_OS_ZOS
+#define GET_STACK_POINTER_TO(sp_addr) \
+  __asm__ __volatile__(" stg 15,%0" : "=m"(sp_addr))
 #elif defined(__s390x__) || defined(_ARCH_S390X)
 #define GET_STACK_POINTER_TO(sp_addr) \
   __asm__ __volatile__("stg %%r15, %0" : "=m"(sp_addr))
diff --git a/test/cctest/cctest.status b/test/cctest/cctest.status
index f38b91c968b..9a70dc6e730 100644
--- a/test/cctest/cctest.status
+++ b/test/cctest/cctest.status
@@ -436,6 +436,12 @@
   'test-cpu-profiler/CollectCpuProfileCallerLineNumbers': [PASS, SLOW],
 }],  # 'system == aix or (arch == ppc64 and byteorder == big)'
 
+##############################################################################
+['system == zos', {
+  # Currently no profiler support on z/OS:
+  'test-cpu-profiler/*': [SKIP],
+}],
+
 ##############################################################################
 ['arch == ppc and simulator_run or arch == ppc64 and simulator_run', {
 
diff --git a/test/debugger/debug/regress/regress-662674.js b/test/debugger/debug/regress/regress-662674.js
index 46054a5cd97..e059a8d8e75 100644
--- a/test/debugger/debug/regress/regress-662674.js
+++ b/test/debugger/debug/regress/regress-662674.js
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 // Flags: --stack-size=100
+// Flags(zos): --stack-size=220
 
 Debug = debug.Debug
 
diff --git a/test/debugger/testcfg.py b/test/debugger/testcfg.py
index 864b860d9a9..cdbb2558473 100644
--- a/test/debugger/testcfg.py
+++ b/test/debugger/testcfg.py
@@ -6,6 +6,7 @@ import os
 import re
 
 from testrunner.local import testsuite
+from testrunner.local import utils
 from testrunner.objects import testcase
 
 FILES_PATTERN = re.compile(r"//\s+Files:(.*)")
@@ -31,7 +32,7 @@ class TestCase(testcase.D8TestCase):
 
     source = self.get_source()
     self._source_files = self._parse_source_files(source)
-    self._source_flags = self._parse_source_flags(source)
+    self._source_flags = self._parse_source_flags(source, platform=utils.GuessOS())
 
   def _parse_source_files(self, source):
     files_list = []  # List of file names to append to command arguments.
diff --git a/test/debugging/testcfg.py b/test/debugging/testcfg.py
index 5a4c151253d..44712846215 100644
--- a/test/debugging/testcfg.py
+++ b/test/debugging/testcfg.py
@@ -42,7 +42,7 @@ class TestCase(PYTestCase):
 
     source = self.get_source()
     self._source_files = self._parse_source_files(source)
-    self._source_flags = self._parse_source_flags(source)
+    self._source_flags = self._parse_source_flags(source, platform=utils.GuessOS())
 
   def _parse_source_files(self, source):
     files = []
diff --git a/test/fuzzer/fuzzer.cc b/test/fuzzer/fuzzer.cc
index 96c381e0b6a..90aa91ca5bd 100644
--- a/test/fuzzer/fuzzer.cc
+++ b/test/fuzzer/fuzzer.cc
@@ -32,7 +32,7 @@ int main(int argc, char* argv[]) {
   size_t size = ftell(input);
   fseek(input, 0, SEEK_SET);
 
-  uint8_t* data = reinterpret_cast<uint8_t*>(malloc(size));
+  uint8_t* data = reinterpret_cast<uint8_t*>(malloc(size == 0 ? 1 : size));
   if (!data) {
     fclose(input);
     fprintf(stderr, "Failed to allocate %zu bytes\n", size);
diff --git a/test/inspector/debugger/max-async-call-chain-depth.js b/test/inspector/debugger/max-async-call-chain-depth.js
index ae98f55037b..8699bf2d6a4 100644
--- a/test/inspector/debugger/max-async-call-chain-depth.js
+++ b/test/inspector/debugger/max-async-call-chain-depth.js
@@ -69,9 +69,10 @@ InspectorTest.runAsyncTestSuite([
 
     runWithAsyncChainSetTimeout(9, 'console.trace(42);');
     dumpAsyncChainLength(await Protocol.Runtime.onceConsoleAPICalled());
-
+/* gabylbTODO-HERE */
     runWithAsyncChainSetTimeout(32, 'console.trace(42);');
     dumpAsyncChainLength(await Protocol.Runtime.onceConsoleAPICalled());
+/* */
   },
 
   async function testConsoleTraceWithEmptySync() {
diff --git a/test/inspector/inspector.status b/test/inspector/inspector.status
index a7636baef5e..81b1e26c089 100644
--- a/test/inspector/inspector.status
+++ b/test/inspector/inspector.status
@@ -105,6 +105,13 @@
   'cpu-profiler/console-profile-wasm': [SKIP],
 }],  # 'arch == s390x or arch == ppc64'
 
+##############################################################################
+['system == zos', {
+  # Currently no cpu profiler support on z/OS:
+  'cpu-profiler/console-profile-wasm': [SKIP],
+  'cpu-profiler/record-cpu-profile': [SKIP],
+}],  # 'system == zos'
+
 ##############################################################################
 ['no_simd_hardware', {
   # Test contains SIMD value.
diff --git a/test/inspector/testcfg.py b/test/inspector/testcfg.py
index 6dd8717d216..1be6014b574 100644
--- a/test/inspector/testcfg.py
+++ b/test/inspector/testcfg.py
@@ -38,7 +38,7 @@ class TestCase(testcase.TestCase):
   def __init__(self, *args, **kwargs):
     super(TestCase, self).__init__(*args, **kwargs)
 
-    self._source_flags = self._parse_source_flags()
+    self._source_flags = self._parse_source_flags(platform=utils.GuessOS())
 
   def _get_files_params(self):
     return [
diff --git a/test/intl/testcfg.py b/test/intl/testcfg.py
index b0b9b87cfd9..30da5803bb8 100644
--- a/test/intl/testcfg.py
+++ b/test/intl/testcfg.py
@@ -29,6 +29,7 @@ import os
 import re
 
 from testrunner.local import testsuite
+from testrunner.local import utils
 from testrunner.objects import testcase
 
 ENV_PATTERN = re.compile(r"//\s+Environment Variables:(.*)")
@@ -52,7 +53,7 @@ class TestCase(testcase.D8TestCase):
   def __init__(self, *args, **kwargs):
     super(TestCase, self).__init__(*args, **kwargs)
 
-    self._source_flags = self._parse_source_flags()
+    self._source_flags = self._parse_source_flags(platform=utils.GuessOS())
     source = self.get_source()
     self._env = self._parse_source_env(source)
 
diff --git a/test/message/testcfg.py b/test/message/testcfg.py
index 670994c6cf9..0460147aa77 100644
--- a/test/message/testcfg.py
+++ b/test/message/testcfg.py
@@ -51,7 +51,8 @@ class TestCase(testcase.D8TestCase):
 
     source = self.get_source()
     self._source_files = self._parse_source_files(source)
-    self._source_flags = self._parse_source_flags(source)
+    self._source_flags = self._parse_source_flags(source,
+                                                  platform=utils.GuessOS())
 
   def _parse_source_files(self, source):
     return [self._get_source_path()]
diff --git a/test/mjsunit/mjsunit.status b/test/mjsunit/mjsunit.status
index 470c31b63a7..774b1a7118e 100644
--- a/test/mjsunit/mjsunit.status
+++ b/test/mjsunit/mjsunit.status
@@ -1344,6 +1344,13 @@
   'tools/processor': [PASS, ['component_build', SKIP]],
 }],  # 'system == aix'
 
+##############################################################################
+['system == zos', {
+  # Currently no tz database on z/OS:
+  'tzoffset-seoul-noi18n': [SKIP],
+  'tzoffset-transition-new-york-noi18n': [SKIP],
+}],  # 'system == zos'
+
 ##############################################################################
 ['arch == s390x', {
   # stack overflow
diff --git a/test/mjsunit/regress/regress-1067270.js b/test/mjsunit/regress/regress-1067270.js
index eb505e5b2bf..602b1e42ece 100644
--- a/test/mjsunit/regress/regress-1067270.js
+++ b/test/mjsunit/regress/regress-1067270.js
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 //
 // Flags: --allow-natives-syntax --stack-size=1200
+// Flags(zos): --allow-natives-syntax --stack-size=3200
 
 const needle = Array(1802).join(" +") + Array(16884).join("A");
 const string = "A";
diff --git a/test/mjsunit/regress/wasm/regress-1010272.js b/test/mjsunit/regress/wasm/regress-1010272.js
index 4a37a3a5f5c..3e45e7cd5ef 100644
--- a/test/mjsunit/regress/wasm/regress-1010272.js
+++ b/test/mjsunit/regress/wasm/regress-1010272.js
@@ -2,9 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-// Flags: --wasm-grow-shared-memory
+// Flags: --wasm-grow-shared-memory -e kNumWorkers=100
+// Flags(zos): --wasm-grow-shared-memory -e kNumWorkers=15
 
-const kNumWorkers = 100;
 const kNumMessages = 50;
 
 function AllocMemory(initial, maximum = initial) {
diff --git a/test/mjsunit/testcfg.py b/test/mjsunit/testcfg.py
index aadb4fc2c58..84a7a85701f 100644
--- a/test/mjsunit/testcfg.py
+++ b/test/mjsunit/testcfg.py
@@ -32,6 +32,7 @@ import re
 
 from testrunner.local import statusfile
 from testrunner.local import testsuite
+from testrunner.local import utils
 from testrunner.objects import testcase
 from testrunner.outproc import base as outproc
 
@@ -109,7 +110,7 @@ class TestCase(testcase.D8TestCase):
       mjsunit_files.append(self.suite.root / "mjsunit_numfuzz.js")
 
     self._source_files = files
-    self._source_flags = self._parse_source_flags(source)
+    self._source_flags = self._parse_source_flags(source, platform=utils.GuessOS())
     self._mjsunit_files = mjsunit_files
     self._files_suffix = [testfilename]
     self._env = self._parse_source_env(source)
diff --git a/test/mkgrokdump/BUILD.gn b/test/mkgrokdump/BUILD.gn
index f0167070a09..1b12cd5d576 100644
--- a/test/mkgrokdump/BUILD.gn
+++ b/test/mkgrokdump/BUILD.gn
@@ -21,6 +21,9 @@ v8_executable("mkgrokdump") {
     "../..:v8_libplatform",
     "//build/win:default_exe_manifest",
   ]
+  if (current_os == "zos" && is_component_build) {
+    deps += [ "../../:zoslib" ]
+  }
 
   data_deps = [ "../../tools:v8_testrunner" ]
 
diff --git a/test/unittests/BUILD.gn b/test/unittests/BUILD.gn
index b2f79f51f3a..4fa38301e33 100644
--- a/test/unittests/BUILD.gn
+++ b/test/unittests/BUILD.gn
@@ -87,6 +87,9 @@ v8_source_set("v8_heap_base_unittests_sources") {
     "//testing/gmock",
     "//testing/gtest",
   ]
+  if (current_os == "zos" && is_component_build) {
+    deps += [ "../../:zoslib" ]
+  }
 }
 
 # Stand-alone target for C++ GC unittests. This is used to ensure that it
@@ -828,6 +831,9 @@ v8_executable("generate-bytecode-expectations") {
     "../..:v8_libplatform",
     "//build/win:default_exe_manifest",
   ]
+  if (current_os == "zos" && is_component_build) {
+    deps += [ "../..:zoslib" ]
+  }
 
   data = [ "interpreter/bytecode_expectations/" ]
 }
diff --git a/test/unittests/api/isolate-unittest.cc b/test/unittests/api/isolate-unittest.cc
index a5691b95db5..302b6882a23 100644
--- a/test/unittests/api/isolate-unittest.cc
+++ b/test/unittests/api/isolate-unittest.cc
@@ -134,7 +134,14 @@ TEST_F(IncumbentContextTest, Basic) {
 }
 
 namespace {
+#if V8_OS_ZOS
+// TODO(gabylb): zos - undo when thread_local is supported.
+[[clang::no_destroy]]
+__tlssim<std::map<v8::CrashKeyId, std::string>> __crash_keys_impl;
+#define crash_keys (*__crash_keys_impl.access())
+#else
 thread_local std::multimap<v8::CrashKeyId, std::string> crash_keys;
+#endif
 void CrashKeyCallback(v8::CrashKeyId id, const std::string& value) {
   crash_keys.insert({id, value});
 }
diff --git a/test/unittests/libsampler/signals-and-mutexes-unittest.cc b/test/unittests/libsampler/signals-and-mutexes-unittest.cc
index a72b47660df..281178efbbc 100644
--- a/test/unittests/libsampler/signals-and-mutexes-unittest.cc
+++ b/test/unittests/libsampler/signals-and-mutexes-unittest.cc
@@ -35,6 +35,7 @@ struct sigaction old_signal_handler;
 
 void InstallSignalHandler() {
   struct sigaction sa;
+  memset(&sa, 0, sizeof(sa));
   sa.sa_sigaction = &HandleProfilerSignal;
   sigemptyset(&sa.sa_mask);
   sa.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;
diff --git a/test/unittests/run-all-unittests.cc b/test/unittests/run-all-unittests.cc
index 3237b751411..82277400328 100644
--- a/test/unittests/run-all-unittests.cc
+++ b/test/unittests/run-all-unittests.cc
@@ -48,9 +48,13 @@ int main(int argc, char** argv) {
   testing::FLAGS_gtest_death_test_style = "threadsafe";
 
   testing::InitGoogleMock(&argc, argv);
-  testing::AddGlobalTestEnvironment(new CppGCEnvironment);
+  // TODO(gabylb): zos - auto-destruct of this causes some 10 tests to fail.
+  CppGCEnvironment *penv = new CppGCEnvironment;
+  testing::AddGlobalTestEnvironment(penv);
   v8::V8::SetFlagsFromCommandLine(&argc, argv, true);
   v8::V8::InitializeExternalStartupData(argv[0]);
   v8::V8::InitializeICUDefaultLocation(argv[0]);
-  return RUN_ALL_TESTS();
+  int rc = RUN_ALL_TESTS();
+  delete penv;
+  return rc;
 }
diff --git a/test/unittests/test-utils.h b/test/unittests/test-utils.h
index ebf1eca30bc..93b92c7abb0 100644
--- a/test/unittests/test-utils.h
+++ b/test/unittests/test-utils.h
@@ -622,6 +622,9 @@ class FakeCodeEventLogger : public i::CodeEventLogger {
 #elif V8_HOST_ARCH_MIPS64
 #define GET_STACK_POINTER_TO(sp_addr) \
   __asm__ __volatile__("sd $sp, %0" : "=g"(sp_addr))
+#elif V8_OS_ZOS
+#define GET_STACK_POINTER_TO(sp_addr) \
+  __asm__ __volatile__(" stg 15,%0" : "=m"(sp_addr))
 #elif defined(__s390x__) || defined(_ARCH_S390X)
 #define GET_STACK_POINTER_TO(sp_addr) \
   __asm__ __volatile__("stg %%r15, %0" : "=m"(sp_addr))
diff --git a/test/unittests/utils/allocation-unittest.cc b/test/unittests/utils/allocation-unittest.cc
index 56c639850db..48e138b6171 100644
--- a/test/unittests/utils/allocation-unittest.cc
+++ b/test/unittests/utils/allocation-unittest.cc
@@ -47,6 +47,7 @@ class MemoryAllocationPermissionsTest : public TestWithPlatform {
  protected:
   void SetUp() override {
     struct sigaction action;
+    memset(&action, 0, sizeof(action));
     action.sa_sigaction = SignalHandler;
     sigemptyset(&action.sa_mask);
     action.sa_flags = SA_SIGINFO;
diff --git a/test/unittests/wasm/memory-protection-unittest.cc b/test/unittests/wasm/memory-protection-unittest.cc
index 160f81a361b..16ddf18c187 100644
--- a/test/unittests/wasm/memory-protection-unittest.cc
+++ b/test/unittests/wasm/memory-protection-unittest.cc
@@ -165,6 +165,7 @@ class ParameterizedMemoryProtectionTestWithSignalHandling
       CHECK_NULL(current_handler_scope_);
       current_handler_scope_ = this;
       struct sigaction sa;
+      memset(&sa, 0, sizeof(sa));
       sa.sa_sigaction = &HandleSignal;
       sigemptyset(&sa.sa_mask);
       sa.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;
diff --git a/test/webkit/testcfg.py b/test/webkit/testcfg.py
index d690719939f..f0a25a72cda 100644
--- a/test/webkit/testcfg.py
+++ b/test/webkit/testcfg.py
@@ -29,6 +29,7 @@ import os
 import re
 
 from testrunner.local import testsuite
+from testrunner.local import utils
 from testrunner.objects import testcase
 from testrunner.outproc import webkit
 
@@ -56,7 +57,7 @@ class TestCase(testcase.D8TestCase):
 
     source = self.get_source()
     self._source_files = self._parse_source_files(source)
-    self._source_flags = self._parse_source_flags(source)
+    self._source_flags = self._parse_source_flags(source, platform=utils.GuessOS())
 
   def _parse_source_files(self, source):
     files_list = []  # List of file names to append to command arguments.
diff --git a/tools/testrunner/local/command.py b/tools/testrunner/local/command.py
index b9a6eb51d46..b8237067b76 100644
--- a/tools/testrunner/local/command.py
+++ b/tools/testrunner/local/command.py
@@ -246,6 +246,16 @@ class PosixCommand(DesktopCommand):
     # Forcefully kill processes.
     os.killpg(process.pid, signal.SIGKILL)
 
+    if sys.platform == 'zos' and process.poll() is None:
+      # Use killharder z/OS utility (even 'kill -SIGKILL' from the command line
+      # doesn't always kill a process.):
+      from distutils.spawn import find_executable
+      if find_executable('killharder') is not None:
+        os.system('killharder ' + str(process.pid))
+      else:
+        # Using SIGTERM instead of SIGKILL has been shown to work in some cases.
+        process.terminate()
+
 
 def taskkill_windows(process, verbose=False, force=True):
   force_flag = ' /F' if force else ''
diff --git a/tools/testrunner/local/statusfile.py b/tools/testrunner/local/statusfile.py
index e2aeaf5dc7f..7a319c70f55 100644
--- a/tools/testrunner/local/statusfile.py
+++ b/tools/testrunner/local/statusfile.py
@@ -62,7 +62,7 @@ for var in [
     "debug", "release", "big", "little", "android", "arm", "arm64", "ia32",
     "mips64", "mips64el", "x64", "ppc", "ppc64", "s390", "s390x", "macos",
     "windows", "linux", "aix", "r1", "r2", "r3", "r5", "r6", "riscv32",
-    "riscv64", "loong64"
+    "riscv64", "loong64", "zos"
 ]:
   assert var not in VARIABLES
   VARIABLES[var] = var
diff --git a/tools/testrunner/local/utils.py b/tools/testrunner/local/utils.py
index a73941021b8..470ee1ae28b 100644
--- a/tools/testrunner/local/utils.py
+++ b/tools/testrunner/local/utils.py
@@ -88,6 +88,8 @@ def GuessOS():
   elif system in ['AIX', 'OS400']:
     # OS400 runs an AIX emulator called PASE
     return 'aix'
+  elif system == "OS/390":
+    return 'zos'
   else:
     return None
 
@@ -95,6 +97,12 @@ def GuessOS():
 # Check if Vector Enhancement Facility 1 is available on the
 # host S390 machine. This facility is required for supporting Simd on V8.
 def IsS390SimdSupported():
+  if GuessOS() == 'zos':
+    from ctypes import CDLL
+    libname = os.environ.get('ZOSLIB_LIBPATH') + '/libzoslib.so'
+    clib = CDLL(libname)
+    return clib.__is_vef1_available()
+
   import subprocess
   cpuinfo = subprocess.check_output("cat /proc/cpuinfo", shell=True)
   cpuinfo_list = cpuinfo.strip().decode("utf-8").splitlines()
diff --git a/tools/testrunner/objects/testcase.py b/tools/testrunner/objects/testcase.py
index a1c2919b900..312c18d3881 100644
--- a/tools/testrunner/objects/testcase.py
+++ b/tools/testrunner/objects/testcase.py
@@ -343,10 +343,10 @@ class TestCase(object):
 
   def _get_cmd_params(self):
     """Gets all command parameters and combines them in the following order:
-      - files [empty by default]
       - all flags
+      - files [empty by default]
     """
-    return (self._get_files_params() + self.get_flags())
+    return (self.get_flags() + self._get_files_params())
 
   def get_flags(self):
     """Gets all flags and combines them in the following order:
@@ -454,11 +454,16 @@ class TestCase(object):
         log_process_stats=self.test_config.log_process_stats,
     )
 
-  def _parse_source_flags(self, source=None):
+  def _parse_source_flags(self, source=None, platform=None):
     source = source or self.get_source()
     flags = []
-    for match in re.findall(FLAGS_PATTERN, source):
-      flags += shlex.split(match.strip())
+    if platform is not None:
+      for match in re.findall(re.compile(r"//\s+Flags\(" +
+                   re.escape(platform) + "\):(.*)"), source):
+        flags += shlex.split(match.strip())
+    if not flags:
+      for match in re.findall(FLAGS_PATTERN, source):
+        flags += shlex.split(match.strip())
     return flags
 
   def is_source_available(self):
diff --git a/tools/wasm/BUILD.gn b/tools/wasm/BUILD.gn
index cc438b24bc5..e47510e7232 100644
--- a/tools/wasm/BUILD.gn
+++ b/tools/wasm/BUILD.gn
@@ -24,6 +24,9 @@ v8_executable("wami") {
     "../..:v8_libbase",
     "../..:v8_libplatform",
   ]
+  if (current_os == "zos" && is_component_build) {
+    deps += [ "../../:zoslib" ]
+  }
 
   sources = [ "module-inspector.cc" ]
 
